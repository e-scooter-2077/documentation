const local_index = {"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Introduction This autogenerated website stores all the relevant artifacts produced to document the process of designing the system following a Domain Driven approach as well as the final architecture of the solution. Project Proposal Members Samuele Burattini: samuele.burattini@studio.unibo.it Luca Deluigi: luca.deluigi3@studio.unibo.it Francesco Dente: francesco.dente@studio.unibo.it Simone Magnani: simone.magnani4@studio.unibo.it Scenario The group is committed to design a microservice system that collects and merge e-scooter related data to create a digital twin of the physical entity. The collected data will be: Battery percentage Position and speed in real-time Activity status (rented, idle, etc.) Lock state Availability for renting Any other relevant data discovered while developing The goal is to maximize the coverage of the renting service by analyzing users and scooters behaviour to map the more requested areas and which kind of trips the users do most in different areas. To also make use of the power of the digital twins onto their corresponding physical device a mechanism of battery conservation is put in place to guarantee a long lasting battery life by limiting speed when the battery is too low and a remote locking and disabling mechanism that activates when the scooter is outside of the recovery service area or when the battery is below the minimum threshold to guarantee the device not to turn off. Monitoring will be made possible through an admin dashboard that show the overall state of all the devices in real-time. Course requirements The system will be designed with a domain driven approach. In detail the team will have: an initial knowledge crunching session (with fake domain experts) the definition, mantain and use of the ubiquitous language a requirement analysis, carried out through user stories and use-case diagrams bounded context partitioning and definition of a context-map domain models for each relevant bounded context Apart from that the project will follow a development process based on continuos integration & deployment for most of the system components. The tools used will be: Dotnet CLI for build automation Github Actions for continuous integration Github Pages for the hosting of the automatically generated documentation website Microsoft Azure as a target platform for the deployment of the whole system Quality Assurance tools to be defined during developement (linter, automatic testing etc.)","title":"Introduction"},{"location":"index.html#introduction","text":"This autogenerated website stores all the relevant artifacts produced to document the process of designing the system following a Domain Driven approach as well as the final architecture of the solution.","title":"Introduction"},{"location":"index.html#project-proposal","text":"","title":"Project Proposal"},{"location":"index.html#members","text":"Samuele Burattini: samuele.burattini@studio.unibo.it Luca Deluigi: luca.deluigi3@studio.unibo.it Francesco Dente: francesco.dente@studio.unibo.it Simone Magnani: simone.magnani4@studio.unibo.it","title":"Members"},{"location":"index.html#scenario","text":"The group is committed to design a microservice system that collects and merge e-scooter related data to create a digital twin of the physical entity. The collected data will be: Battery percentage Position and speed in real-time Activity status (rented, idle, etc.) Lock state Availability for renting Any other relevant data discovered while developing The goal is to maximize the coverage of the renting service by analyzing users and scooters behaviour to map the more requested areas and which kind of trips the users do most in different areas. To also make use of the power of the digital twins onto their corresponding physical device a mechanism of battery conservation is put in place to guarantee a long lasting battery life by limiting speed when the battery is too low and a remote locking and disabling mechanism that activates when the scooter is outside of the recovery service area or when the battery is below the minimum threshold to guarantee the device not to turn off. Monitoring will be made possible through an admin dashboard that show the overall state of all the devices in real-time.","title":"Scenario"},{"location":"index.html#course-requirements","text":"The system will be designed with a domain driven approach. In detail the team will have: an initial knowledge crunching session (with fake domain experts) the definition, mantain and use of the ubiquitous language a requirement analysis, carried out through user stories and use-case diagrams bounded context partitioning and definition of a context-map domain models for each relevant bounded context Apart from that the project will follow a development process based on continuos integration & deployment for most of the system components. The tools used will be: Dotnet CLI for build automation Github Actions for continuous integration Github Pages for the hosting of the automatically generated documentation website Microsoft Azure as a target platform for the deployment of the whole system Quality Assurance tools to be defined during developement (linter, automatic testing etc.)","title":"Course requirements"},{"location":"CONTRIBUTING.html","text":"Contributing to the documentation Preview the results You can use Docker to install and run the website generation tool . Download the docker image docker pull deloo/markdown-docs Generate the website docker run -e \"WORKSPACE=/workspace\" -v \"<Absolute-Path-To-The-Repo>:/workspace\" markdown-docs \"./\" \"dest/\" !> Clean the output directory before each new generation with rmdir dest /s /q (on Windows). !> Remember to replace <Absolute-Path-To-The-Repo> . See the result explorer dest\\index.html","title":"Contributing to the documentation"},{"location":"CONTRIBUTING.html#contributing-to-the-documentation","text":"","title":"Contributing to the documentation"},{"location":"CONTRIBUTING.html#preview-the-results","text":"You can use Docker to install and run the website generation tool .","title":"Preview the results"},{"location":"CONTRIBUTING.html#download-the-docker-image","text":"docker pull deloo/markdown-docs","title":"Download the docker image"},{"location":"CONTRIBUTING.html#generate-the-website","text":"docker run -e \"WORKSPACE=/workspace\" -v \"<Absolute-Path-To-The-Repo>:/workspace\" markdown-docs \"./\" \"dest/\" !> Clean the output directory before each new generation with rmdir dest /s /q (on Windows). !> Remember to replace <Absolute-Path-To-The-Repo> .","title":"Generate the website"},{"location":"CONTRIBUTING.html#see-the-result","text":"explorer dest\\index.html","title":"See the result"},{"location":"SUMMARY.html","text":"Introduction Domain Exploration Requirement Analysis Domain Analysis Architecture Design DevOps Engineering Implementation Conclusions","title":"SUMMARY"},{"location":"conclusions.html","text":"Conclusions This project proved to be a great challenge in trying to be coherent through time with all the notions from the course. Keeping a clean developement process during the timespan of the project was quite hard partially due to both the use of the Azure Cloud, which was new for basically all the team members, and the fragmentation in time dedicated to the project caused by other personal and academic obligations that didn't allow to have a smooth route from start to finish. Even so, the team agrees that it was a good way to see in practice the strenghts and challenges of the techniques studied during the course in a \"real world\" scenario. Domain Driven Design Concerning the Domain Driven Design the team started with a long planning session to try to pin down all the concepts and have a clear holistic view of the whole system. Then after studying the technology chosen to implement the system itself some clashes emerged and it was a bit harder to constantly update the documentation to match in real-time what was happening with the software. This was identified as the most challenging aspect of the DDD, whilst the analysis process carried out with the tools and the philosophy transmitted during the course felt quite natural and effective since the beginning. In retrospective the team feels that some cleaner and more coherent with the Ubiquitous Language code could have been created, but, while developing, that felt unnecessary and overcomplex for smaller pieces of software like the Azure Functions and instead was useful for bigger artifacts like the services and the scooter-emulator. DevOps process From a DevOps perspective the team put a lot of effort in the automatization of the quality assurance and the deployment of the whole system. This really helped in having a clean, self updating system especially since we were dealing with a cloud service. Testing was a bit left behind primarily for time management reasons and because most of the testing was done while integrating different software components instead of having complex business logic that needed intensive single unit tests. Overall setting up a pipeline from the very beginning resulted in a helpful tool that guided each team member during the development of the system.","title":"Conclusions"},{"location":"conclusions.html#conclusions","text":"This project proved to be a great challenge in trying to be coherent through time with all the notions from the course. Keeping a clean developement process during the timespan of the project was quite hard partially due to both the use of the Azure Cloud, which was new for basically all the team members, and the fragmentation in time dedicated to the project caused by other personal and academic obligations that didn't allow to have a smooth route from start to finish. Even so, the team agrees that it was a good way to see in practice the strenghts and challenges of the techniques studied during the course in a \"real world\" scenario.","title":"Conclusions"},{"location":"conclusions.html#domain-driven-design","text":"Concerning the Domain Driven Design the team started with a long planning session to try to pin down all the concepts and have a clear holistic view of the whole system. Then after studying the technology chosen to implement the system itself some clashes emerged and it was a bit harder to constantly update the documentation to match in real-time what was happening with the software. This was identified as the most challenging aspect of the DDD, whilst the analysis process carried out with the tools and the philosophy transmitted during the course felt quite natural and effective since the beginning. In retrospective the team feels that some cleaner and more coherent with the Ubiquitous Language code could have been created, but, while developing, that felt unnecessary and overcomplex for smaller pieces of software like the Azure Functions and instead was useful for bigger artifacts like the services and the scooter-emulator.","title":"Domain Driven Design"},{"location":"conclusions.html#devops-process","text":"From a DevOps perspective the team put a lot of effort in the automatization of the quality assurance and the deployment of the whole system. This really helped in having a clean, self updating system especially since we were dealing with a cloud service. Testing was a bit left behind primarily for time management reasons and because most of the testing was done while integrating different software components instead of having complex business logic that needed intensive single unit tests. Overall setting up a pipeline from the very beginning resulted in a helpful tool that guided each team member during the development of the system.","title":"DevOps process"},{"location":"devops-engineering.html","text":"DevOps Engineering DevOps is considered a fundamental part of a microservice based system. In this section, we will discuss the tools and methodologies put in practice by the team. DVCS Strategy Having a large set of repositories, each typically maintained by a single developer (or at most two using pair-programming), the chosen branching strategy is Trunk-based . This simplifies the management of the repositories by individual developers, while still giving them the possibility to occasionally open feature/hotfix branches if needed. Licenses Each piece of software made is provided under the MIT License , which makes it FOSS . Versioning Each of the softwares developed is versioned with the Semantic Versioning system. We used git annotated tags to declare new versions, and based our release system on that. We created a tool that searches for the latest tag and generates a version for our build automation. Software Build Lifecycle Every step of the software build lifecycle was automated through Git and GitHub Actions . GitHub Actions offers hosted containers (called runners ) that run many kind of scripts divided in flows and tasks, in an imperative fashion. Many script reuse techniques are possible. We used: Custom Actions Reusable Workflows Repository templating Principles adopted These are the principles we adopted for every repository: Commits should adhere at the Imperative tense, impersonal form. Versions are managed with git tags, specifically in the form v#.#.# . At each push, software build and tests are performed. When a new tag is pushed, after a successful test job, a release is performed. Releases happen on the GitHub Release page and trigger a deploy. We used Azure Cloud as our deploy destination for each software components, so that part of the workflow is shared between similar projects. Consistency between .NET compilation target, runtime target, build-time dotnet version. GitHub Actions Workflows Workflows define the automation processes of a repository. An example of a workflow that was created by us and used in this project can be found here . Workflows are composed by jobs which can run concurrently or in sequence based on a graph of dependencies between each other. Each job is composed by a sequence of steps to be made. Steps can fail, when it happens normally the job is interrupted and flagged as failed. Steps can run scripts or actions. Every action takes care of one build step. Some custom actions aggregate repeated steps into a single one (see Composite Actions ). Actions we developed in first person Some members of the team had previously developed custom GitHub Actions for their projects and reused them for EScooter. These are: Markdown Docs - Generates a website from markdown files. SemVer Checkout - Checkouts the full history of a repo to determine the software version with semantic versioning. SemVer Release - Creates a GitHub release of the software artifacts using its semantic version, generating a changelog. Dotnet Build - Runs dotnet restore & dotnet build. Dotnet Test - Runs the tests with dotnet. Dotnet Publish - Produces a folder with the final .exe file and all its dependencies. Reusable workflows After the release of reusable workflows by GitHub, as DRY principles were applied extensively between all the repositories, two singleton workflow file were created so that each piece of software implemented with .NET would call them instead of repeating the same workflow making updating the workflow between projects and mantaining the same standard easier. One was created for Azure Functions CI/CD to include delivery on the cloud resource, one for Dekstop applications and Hosted Runners CI/CD . Workflow Design The two main workflows the team designed are: Azure Functions CI C# App CI They both start with a build job (Continuous Integration) consisting of checkout, building (compiling + linking), unit testing, publishing (artifact generation) and artifact uploading (artifacts on GitHub aren't volatile, they are kept for about a day based on the configuration). The release (Continuous Delivery) job is run only if a new tag respecting Semantic Versioning gets pushed. This job creates a GitHub release and uploads the binaries. The Azure Functions CI provides also the deploy job (Continuous Deployment), which uploads the function to the relative slot on Azure Cloud. The analyze job, present in both the workflows, builds the sources with CodeQL and runs all the default code quality and security queries, provided by the CodeQL team, reporting results in the Security tab of the repository. The outcome of the analysis is ignored for the purposes of build success, because CodeQL proved to be slightly unstable and too computational expensive (time and memory) to be waited every time. Other reusable workflows adopted Rent service CI/CD uses the following workflows: Microservice Build Microservice Azure Deploy These workflows were developed by some members of the team for a different project. Repository templates Repository templates allow a faster bootstrap phase of a project, scaffolding a hello world version of the program to be developed. This includes the automatic generation of the build lifecycle from the very first commit. The template we made for every EScooter Azure Function can be found here . Microservice template A template we used for microservices but we made for a different project can be found here . It makes use of the Clean Architecture library we made. Other tools We created a script for the Git Bash that adds a git release command to git to quickly create new patch, new minor or new major versions of our software based on the repository history. The code can be found here . Quality control We configured each C# project with a consistent style rulesheet inside the .editorconfig file. StyleCop Analyzers takes care of enforncing the style we designed both during development and during automated builds. Check Style warnings are treated as errors. Static Code Analysis Static code analysis for the C# language is performed automatically within the CI pipeline for every azure function project. Reports are put under the Security tab of the relative GitHub project. The tool used for the analysis is CodeQL . Both security and code quality alerts are enabled. Documentation Tools We automated documentation generation of both the architecture of the system (in this repository) and the API of our microservices with a Swagger plugin for ASP.NET (see the Rent Service API docs as an example). Ignored aspects Public repository (NuGet) Given the fact that we didn't develop libraries, but only single-purpose services and functions, we didn't use NuGet. Dependency inspection/automatic management We voluntarily ignored the real-time dependency and vulnerability management because of the finite scope of the project. We instead used automatic dependancy and vulnerability management offered by GitHub (such as Dependabot) in some previously made actions, such as Markdown Docs , which Luca Deluigi is actively maintaining as one of his OS projects. See the dependabot configuration file . Dependabot creates automatic pull requests that suggest dependency updates. We wanted to avoid receiving those PRs forever.","title":"DevOps Engineering"},{"location":"devops-engineering.html#devops-engineering","text":"DevOps is considered a fundamental part of a microservice based system. In this section, we will discuss the tools and methodologies put in practice by the team.","title":"DevOps Engineering"},{"location":"devops-engineering.html#dvcs-strategy","text":"Having a large set of repositories, each typically maintained by a single developer (or at most two using pair-programming), the chosen branching strategy is Trunk-based . This simplifies the management of the repositories by individual developers, while still giving them the possibility to occasionally open feature/hotfix branches if needed.","title":"DVCS Strategy"},{"location":"devops-engineering.html#licenses","text":"Each piece of software made is provided under the MIT License , which makes it FOSS .","title":"Licenses"},{"location":"devops-engineering.html#versioning","text":"Each of the softwares developed is versioned with the Semantic Versioning system. We used git annotated tags to declare new versions, and based our release system on that. We created a tool that searches for the latest tag and generates a version for our build automation.","title":"Versioning"},{"location":"devops-engineering.html#software-build-lifecycle","text":"Every step of the software build lifecycle was automated through Git and GitHub Actions . GitHub Actions offers hosted containers (called runners ) that run many kind of scripts divided in flows and tasks, in an imperative fashion. Many script reuse techniques are possible. We used: Custom Actions Reusable Workflows Repository templating","title":"Software Build Lifecycle"},{"location":"devops-engineering.html#principles-adopted","text":"These are the principles we adopted for every repository: Commits should adhere at the Imperative tense, impersonal form. Versions are managed with git tags, specifically in the form v#.#.# . At each push, software build and tests are performed. When a new tag is pushed, after a successful test job, a release is performed. Releases happen on the GitHub Release page and trigger a deploy. We used Azure Cloud as our deploy destination for each software components, so that part of the workflow is shared between similar projects. Consistency between .NET compilation target, runtime target, build-time dotnet version.","title":"Principles adopted"},{"location":"devops-engineering.html#github-actions-workflows","text":"Workflows define the automation processes of a repository. An example of a workflow that was created by us and used in this project can be found here . Workflows are composed by jobs which can run concurrently or in sequence based on a graph of dependencies between each other. Each job is composed by a sequence of steps to be made. Steps can fail, when it happens normally the job is interrupted and flagged as failed. Steps can run scripts or actions. Every action takes care of one build step. Some custom actions aggregate repeated steps into a single one (see Composite Actions ). Actions we developed in first person Some members of the team had previously developed custom GitHub Actions for their projects and reused them for EScooter. These are: Markdown Docs - Generates a website from markdown files. SemVer Checkout - Checkouts the full history of a repo to determine the software version with semantic versioning. SemVer Release - Creates a GitHub release of the software artifacts using its semantic version, generating a changelog. Dotnet Build - Runs dotnet restore & dotnet build. Dotnet Test - Runs the tests with dotnet. Dotnet Publish - Produces a folder with the final .exe file and all its dependencies.","title":"GitHub Actions Workflows"},{"location":"devops-engineering.html#reusable-workflows","text":"After the release of reusable workflows by GitHub, as DRY principles were applied extensively between all the repositories, two singleton workflow file were created so that each piece of software implemented with .NET would call them instead of repeating the same workflow making updating the workflow between projects and mantaining the same standard easier. One was created for Azure Functions CI/CD to include delivery on the cloud resource, one for Dekstop applications and Hosted Runners CI/CD .","title":"Reusable workflows"},{"location":"devops-engineering.html#workflow-design","text":"The two main workflows the team designed are: Azure Functions CI C# App CI They both start with a build job (Continuous Integration) consisting of checkout, building (compiling + linking), unit testing, publishing (artifact generation) and artifact uploading (artifacts on GitHub aren't volatile, they are kept for about a day based on the configuration). The release (Continuous Delivery) job is run only if a new tag respecting Semantic Versioning gets pushed. This job creates a GitHub release and uploads the binaries. The Azure Functions CI provides also the deploy job (Continuous Deployment), which uploads the function to the relative slot on Azure Cloud. The analyze job, present in both the workflows, builds the sources with CodeQL and runs all the default code quality and security queries, provided by the CodeQL team, reporting results in the Security tab of the repository. The outcome of the analysis is ignored for the purposes of build success, because CodeQL proved to be slightly unstable and too computational expensive (time and memory) to be waited every time. Other reusable workflows adopted Rent service CI/CD uses the following workflows: Microservice Build Microservice Azure Deploy These workflows were developed by some members of the team for a different project.","title":"Workflow Design"},{"location":"devops-engineering.html#repository-templates","text":"Repository templates allow a faster bootstrap phase of a project, scaffolding a hello world version of the program to be developed. This includes the automatic generation of the build lifecycle from the very first commit. The template we made for every EScooter Azure Function can be found here . Microservice template A template we used for microservices but we made for a different project can be found here . It makes use of the Clean Architecture library we made.","title":"Repository templates"},{"location":"devops-engineering.html#other-tools","text":"We created a script for the Git Bash that adds a git release command to git to quickly create new patch, new minor or new major versions of our software based on the repository history. The code can be found here .","title":"Other tools"},{"location":"devops-engineering.html#quality-control","text":"We configured each C# project with a consistent style rulesheet inside the .editorconfig file. StyleCop Analyzers takes care of enforncing the style we designed both during development and during automated builds. Check Style warnings are treated as errors.","title":"Quality control"},{"location":"devops-engineering.html#static-code-analysis","text":"Static code analysis for the C# language is performed automatically within the CI pipeline for every azure function project. Reports are put under the Security tab of the relative GitHub project. The tool used for the analysis is CodeQL . Both security and code quality alerts are enabled.","title":"Static Code Analysis"},{"location":"devops-engineering.html#documentation-tools","text":"We automated documentation generation of both the architecture of the system (in this repository) and the API of our microservices with a Swagger plugin for ASP.NET (see the Rent Service API docs as an example).","title":"Documentation Tools"},{"location":"devops-engineering.html#ignored-aspects","text":"","title":"Ignored aspects"},{"location":"devops-engineering.html#public-repository-nuget","text":"Given the fact that we didn't develop libraries, but only single-purpose services and functions, we didn't use NuGet.","title":"Public repository (NuGet)"},{"location":"devops-engineering.html#dependency-inspectionautomatic-management","text":"We voluntarily ignored the real-time dependency and vulnerability management because of the finite scope of the project. We instead used automatic dependancy and vulnerability management offered by GitHub (such as Dependabot) in some previously made actions, such as Markdown Docs , which Luca Deluigi is actively maintaining as one of his OS projects. See the dependabot configuration file . Dependabot creates automatic pull requests that suggest dependency updates. We wanted to avoid receiving those PRs forever.","title":"Dependency inspection/automatic management"},{"location":"API/v0/paginate.html","text":"a paginated response includes a field meta as the following: { \"meta\" : { \"pageNum\" : i nte ger , \"pageSize\" : i nte ger , \"next\" : s tr i n g } }","title":"Paginate"},{"location":"API/v0/template.html","text":"Context API /path/{urlParams} URL Parameters - urlParams : description GET description Query Parameters - Name : description Body { \"field\" : t ype //Commo n Value } Response Code ***: { \"field\" : t ype //Commo n Value } POST PUT DELETE Outgoing Events Name Fires when { \"field\" : t ype //Commo n Value } Commands Name Subscriptions Service EventName","title":"Context"},{"location":"API/v0/template.html#context","text":"","title":"Context"},{"location":"API/v0/template.html#api","text":"","title":"API"},{"location":"API/v0/template.html#pathurlparams","text":"URL Parameters - urlParams : description","title":"/path/{urlParams}"},{"location":"API/v0/template.html#get","text":"description Query Parameters - Name : description Body { \"field\" : t ype //Commo n Value } Response Code ***: { \"field\" : t ype //Commo n Value }","title":"GET"},{"location":"API/v0/template.html#post","text":"","title":"POST"},{"location":"API/v0/template.html#put","text":"","title":"PUT"},{"location":"API/v0/template.html#delete","text":"","title":"DELETE"},{"location":"API/v0/template.html#outgoing-events","text":"","title":"Outgoing Events"},{"location":"API/v0/template.html#name","text":"Fires when { \"field\" : t ype //Commo n Value }","title":"Name"},{"location":"API/v0/template.html#commands","text":"","title":"Commands"},{"location":"API/v0/template.html#name_1","text":"","title":"Name"},{"location":"API/v0/template.html#subscriptions","text":"","title":"Subscriptions"},{"location":"API/v0/template.html#service","text":"EventName","title":"Service"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html","text":"Area of Service API /areas GET Returns a list of Areas of service. Query Parameters - pageNum : number of requested page given the pageSize - pageSize : elements per page Response Code 200: paginated response { \"data\" : [ { \"id\" : s tr i n g //E nt i t yId } ] } POST Creates a new Area of Service. Body { \"shape\" : objec t //Shape } Response Code 201: { \"id\" : s tr i n g , //E nt i t yId \"shape\" : objec t //Shape } Code 400 /areas/{id} URL Parameters - id : the EntityId that identifies the requested area. GET get the properties of an existing area. Response Code 200: { \"id\" : s tr i n g , //E nt i t yId \"shape\" : objec t , //Shape \"scooters\" : Se t [ s tr i n g ] //Se t [ E nt i t yId ] } Code 400 Code 404 PUT Modify the properties of an existing area. Body { \"shape\" : objec t //Shape } Response Code 200: { \"id\" : s tr i n g , //E nt i t yId \"shape\" : objec t //Shape } Code 400 Code 404 DELETE Removes an Area of Service identified by id. Response Code 200: { \"id\" : s tr i n g , //E nt i t yId \"shape\" : objec t //Shape } Code 404 /areas/{areaId}?contains={scooterId} URL Parameters - areaId : the EntityId that identifies the area in which to search Query Parameters - contains : the EntityId that identifies the requested scooter GET Returns whether a scooter belonging to an area is currently inside tha area boundary. Response Code 200: { \"areaId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g , //E nt i t yId \"isInArea\" : boolea n } Code 404: if the scooter doesn't belong to the selected area or the area doesn't exist. /scooters/{id}?belongsTo={areaId} GET Returns whether a scooter belongs to an Area of Service. URL Parameters - scooterId : the EntityId that identifies the requested scooter Query Parameters - belongsTo : the EntityId that identifies the area in which to search Response Code 200: { \"areaId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g , //E nt i t yId \"belongsToArea\" : boolea n } Code 404: if the scooter or the area doesn't exist. Outgoing Events AreaCreated Fires when a new area is added to the System. { \"id\" : s tr i n g //E nt i t yId } AreaDeleted Fires when a new area is removed from the System. { \"id\" : s tr i n g //E nt i t yId } AreaShapeChanged Fires when the shape of an existing area is modified. { \"id\" : s tr i n g //E nt i t yId } ScooterAssignedToArea Fires when an existing scooter is assigned to an area of service. { \"areaId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g //E nt i t yId } ScooterRemovedFromArea Fires when an existing scooter is removed from an area of service. { \"areaId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g //E nt i t yId } ScooterWentOutsideArea Fires when an existing scooter exits from the boundary of its area of service. { \"areaId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g //E nt i t yId } ScooterReturnedInsideArea Fires when an existing scooter is put back inside the boundary of its area of service. { \"areaId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g //E nt i t yId } Subscriptions Scooter Data ScooterCreated ScooterDeleted","title":"Area of Service"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#area-of-service","text":"","title":"Area of Service"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#api","text":"","title":"API"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#areas","text":"","title":"/areas"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#get","text":"Returns a list of Areas of service. Query Parameters - pageNum : number of requested page given the pageSize - pageSize : elements per page Response Code 200: paginated response { \"data\" : [ { \"id\" : s tr i n g //E nt i t yId } ] }","title":"GET"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#post","text":"Creates a new Area of Service. Body { \"shape\" : objec t //Shape } Response Code 201: { \"id\" : s tr i n g , //E nt i t yId \"shape\" : objec t //Shape } Code 400","title":"POST"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#areasid","text":"URL Parameters - id : the EntityId that identifies the requested area.","title":"/areas/{id}"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#get_1","text":"get the properties of an existing area. Response Code 200: { \"id\" : s tr i n g , //E nt i t yId \"shape\" : objec t , //Shape \"scooters\" : Se t [ s tr i n g ] //Se t [ E nt i t yId ] } Code 400 Code 404","title":"GET"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#put","text":"Modify the properties of an existing area. Body { \"shape\" : objec t //Shape } Response Code 200: { \"id\" : s tr i n g , //E nt i t yId \"shape\" : objec t //Shape } Code 400 Code 404","title":"PUT"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#delete","text":"Removes an Area of Service identified by id. Response Code 200: { \"id\" : s tr i n g , //E nt i t yId \"shape\" : objec t //Shape } Code 404","title":"DELETE"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#areasareaidcontainsscooterid","text":"URL Parameters - areaId : the EntityId that identifies the area in which to search Query Parameters - contains : the EntityId that identifies the requested scooter","title":"/areas/{areaId}?contains={scooterId}"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#get_2","text":"Returns whether a scooter belonging to an area is currently inside tha area boundary. Response Code 200: { \"areaId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g , //E nt i t yId \"isInArea\" : boolea n } Code 404: if the scooter doesn't belong to the selected area or the area doesn't exist.","title":"GET"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#scootersidbelongstoareaid","text":"","title":"/scooters/{id}?belongsTo={areaId}"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#get_3","text":"Returns whether a scooter belongs to an Area of Service. URL Parameters - scooterId : the EntityId that identifies the requested scooter Query Parameters - belongsTo : the EntityId that identifies the area in which to search Response Code 200: { \"areaId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g , //E nt i t yId \"belongsToArea\" : boolea n } Code 404: if the scooter or the area doesn't exist.","title":"GET"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#outgoing-events","text":"","title":"Outgoing Events"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#areacreated","text":"Fires when a new area is added to the System. { \"id\" : s tr i n g //E nt i t yId }","title":"AreaCreated"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#areadeleted","text":"Fires when a new area is removed from the System. { \"id\" : s tr i n g //E nt i t yId }","title":"AreaDeleted"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#areashapechanged","text":"Fires when the shape of an existing area is modified. { \"id\" : s tr i n g //E nt i t yId }","title":"AreaShapeChanged"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#scooterassignedtoarea","text":"Fires when an existing scooter is assigned to an area of service. { \"areaId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g //E nt i t yId }","title":"ScooterAssignedToArea"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#scooterremovedfromarea","text":"Fires when an existing scooter is removed from an area of service. { \"areaId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g //E nt i t yId }","title":"ScooterRemovedFromArea"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#scooterwentoutsidearea","text":"Fires when an existing scooter exits from the boundary of its area of service. { \"areaId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g //E nt i t yId }","title":"ScooterWentOutsideArea"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#scooterreturnedinsidearea","text":"Fires when an existing scooter is put back inside the boundary of its area of service. { \"areaId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g //E nt i t yId }","title":"ScooterReturnedInsideArea"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#subscriptions","text":"","title":"Subscriptions"},{"location":"API/v0/E-Scooter/Area%20of%20Service.html#scooter-data","text":"ScooterCreated ScooterDeleted","title":"Scooter Data"},{"location":"API/v0/E-Scooter/Scooter%20Control.html","text":"Scooter Control Outgoing Events ScooterUnlocked Fires when a scooter is unlocked { \"id\" : s tr i n g //E nt i t yId } ScooterLocked Fires when a scooter is locked { \"id\" : s tr i n g //E nt i t yId } ScooterEnabled Fires when a scooter is enabled { \"id\" : s tr i n g //E nt i t yId } ScooterDisabled Fires when a scooter is disabled { \"id\" : s tr i n g //E nt i t yId } ScooterPowerModeChanged Fires when the power mode of a scooter is changed { \"id\" : s tr i n g , //E nt i t yId \"powerMode\" : s tr i n g //PowerMode } ScooterMaxSpeedChanged Fires when when the max speed of a scooter is changed { \"id\" : s tr i n g , //E nt i t yId \"maxSpeed\" : nu mber //Speed } Subscriptions Scooter Data ScooterCreated ScooterDeleted Area of Service ScooterWentOutsideArea ScooterReturnedInsideArea ScooterRemovedFromArea ScooterAssignedToArea","title":"Scooter Control"},{"location":"API/v0/E-Scooter/Scooter%20Control.html#scooter-control","text":"","title":"Scooter Control"},{"location":"API/v0/E-Scooter/Scooter%20Control.html#outgoing-events","text":"","title":"Outgoing Events"},{"location":"API/v0/E-Scooter/Scooter%20Control.html#scooterunlocked","text":"Fires when a scooter is unlocked { \"id\" : s tr i n g //E nt i t yId }","title":"ScooterUnlocked"},{"location":"API/v0/E-Scooter/Scooter%20Control.html#scooterlocked","text":"Fires when a scooter is locked { \"id\" : s tr i n g //E nt i t yId }","title":"ScooterLocked"},{"location":"API/v0/E-Scooter/Scooter%20Control.html#scooterenabled","text":"Fires when a scooter is enabled { \"id\" : s tr i n g //E nt i t yId }","title":"ScooterEnabled"},{"location":"API/v0/E-Scooter/Scooter%20Control.html#scooterdisabled","text":"Fires when a scooter is disabled { \"id\" : s tr i n g //E nt i t yId }","title":"ScooterDisabled"},{"location":"API/v0/E-Scooter/Scooter%20Control.html#scooterpowermodechanged","text":"Fires when the power mode of a scooter is changed { \"id\" : s tr i n g , //E nt i t yId \"powerMode\" : s tr i n g //PowerMode }","title":"ScooterPowerModeChanged"},{"location":"API/v0/E-Scooter/Scooter%20Control.html#scootermaxspeedchanged","text":"Fires when when the max speed of a scooter is changed { \"id\" : s tr i n g , //E nt i t yId \"maxSpeed\" : nu mber //Speed }","title":"ScooterMaxSpeedChanged"},{"location":"API/v0/E-Scooter/Scooter%20Control.html#subscriptions","text":"","title":"Subscriptions"},{"location":"API/v0/E-Scooter/Scooter%20Control.html#scooter-data","text":"ScooterCreated ScooterDeleted","title":"Scooter Data"},{"location":"API/v0/E-Scooter/Scooter%20Control.html#area-of-service","text":"ScooterWentOutsideArea ScooterReturnedInsideArea ScooterRemovedFromArea ScooterAssignedToArea","title":"Area of Service"},{"location":"API/v0/E-Scooter/Scooter%20Data.html","text":"Scooter Data API /scooters GET Returns a list of Scooters. Query Params - pageNum : number of requested page given the pageSize - pageSize : elements per page Response Code 200: paginated response { \"data\" : [ { \"id\" : s tr i n g //E nt i t yId } ] } POST Creates a new Scooter. Body { \"id\" : s tr i n g , //E nt i t yId \"serialNumber\" : s tr i n g , //SerialNumber \"weight\" : i nte ger , //Weigh t \"model\" : s tr i n g , //ModelI nf o } Response Code 201: { \"id\" : s tr i n g //E nt i t yId } Code 400 /scooters/{id} URL Parameters - id : the EntityId that identifies the requested scooter. GET Returns the detail of the specified scooter. Response Code 200: { \"id\" : s tr i n g , //E nt i t yId \"serialNumber\" : s tr i n g , // SerialNumber \"weight\" : i nte ger , //Weigh t \"model\" : s tr i n g , //ModelI nf o } Code 404 DELETE Removes the specified scooter. Response Code 200: { \"id\" : s tr i n g //E nt i t yId } Code 404 Outgoing Events ScooterCreated Fires when a new scooter is added to the System. { \"id\" : s tr i n g //E nt i t yId } ScooterDeleted Fires when a new scooter is removed from the System. { \"id\" : s tr i n g //E nt i t yId }","title":"Scooter Data"},{"location":"API/v0/E-Scooter/Scooter%20Data.html#scooter-data","text":"","title":"Scooter Data"},{"location":"API/v0/E-Scooter/Scooter%20Data.html#api","text":"","title":"API"},{"location":"API/v0/E-Scooter/Scooter%20Data.html#scooters","text":"","title":"/scooters"},{"location":"API/v0/E-Scooter/Scooter%20Data.html#get","text":"Returns a list of Scooters. Query Params - pageNum : number of requested page given the pageSize - pageSize : elements per page Response Code 200: paginated response { \"data\" : [ { \"id\" : s tr i n g //E nt i t yId } ] }","title":"GET"},{"location":"API/v0/E-Scooter/Scooter%20Data.html#post","text":"Creates a new Scooter. Body { \"id\" : s tr i n g , //E nt i t yId \"serialNumber\" : s tr i n g , //SerialNumber \"weight\" : i nte ger , //Weigh t \"model\" : s tr i n g , //ModelI nf o } Response Code 201: { \"id\" : s tr i n g //E nt i t yId } Code 400","title":"POST"},{"location":"API/v0/E-Scooter/Scooter%20Data.html#scootersid","text":"URL Parameters - id : the EntityId that identifies the requested scooter.","title":"/scooters/{id}"},{"location":"API/v0/E-Scooter/Scooter%20Data.html#get_1","text":"Returns the detail of the specified scooter. Response Code 200: { \"id\" : s tr i n g , //E nt i t yId \"serialNumber\" : s tr i n g , // SerialNumber \"weight\" : i nte ger , //Weigh t \"model\" : s tr i n g , //ModelI nf o } Code 404","title":"GET"},{"location":"API/v0/E-Scooter/Scooter%20Data.html#delete","text":"Removes the specified scooter. Response Code 200: { \"id\" : s tr i n g //E nt i t yId } Code 404","title":"DELETE"},{"location":"API/v0/E-Scooter/Scooter%20Data.html#outgoing-events","text":"","title":"Outgoing Events"},{"location":"API/v0/E-Scooter/Scooter%20Data.html#scootercreated","text":"Fires when a new scooter is added to the System. { \"id\" : s tr i n g //E nt i t yId }","title":"ScooterCreated"},{"location":"API/v0/E-Scooter/Scooter%20Data.html#scooterdeleted","text":"Fires when a new scooter is removed from the System. { \"id\" : s tr i n g //E nt i t yId }","title":"ScooterDeleted"},{"location":"API/v0/E-Scooter/Scooter%20Physical%20Control.html","text":"Scooter Physical Control Outgoing Events ScooterPosition Fires each every predefined certain time { \"id\" : s tr i n g , //E nt i t yId \"position\" : objec t , //Geopoi nt } Subscriptions Scooter Control ScooterUnlocked ScooterLocked ScooterEnabled ScooterDisabled ScooterPoweModeChanged ScooterMaxSpeedChanged","title":"Scooter Physical Control"},{"location":"API/v0/E-Scooter/Scooter%20Physical%20Control.html#scooter-physical-control","text":"","title":"Scooter Physical Control"},{"location":"API/v0/E-Scooter/Scooter%20Physical%20Control.html#outgoing-events","text":"","title":"Outgoing Events"},{"location":"API/v0/E-Scooter/Scooter%20Physical%20Control.html#scooterposition","text":"Fires each every predefined certain time { \"id\" : s tr i n g , //E nt i t yId \"position\" : objec t , //Geopoi nt }","title":"ScooterPosition"},{"location":"API/v0/E-Scooter/Scooter%20Physical%20Control.html#subscriptions","text":"","title":"Subscriptions"},{"location":"API/v0/E-Scooter/Scooter%20Physical%20Control.html#scooter-control","text":"ScooterUnlocked ScooterLocked ScooterEnabled ScooterDisabled ScooterPoweModeChanged ScooterMaxSpeedChanged","title":"Scooter Control"},{"location":"API/v0/Insight/Drop%20Points%20Planning.html","text":"Drop Points Planning API /DropPoints GET Returns the list of the best drop points Query Parameters - pageNum : number of requested page given the pageSize - pageSize : elements per page Response Code 200: paginated response { \"data\" : [ { \"id\" : s tr i n g //E nt i t yId } ] } /DropPoints/{id} URL Parameters - id : the EntityId that identifies the requested drop point. GET get the properties of an existing drop point Response Code 200: { \"id\" : s tr i n g , //E nt i t yId \"position\" : objec t , //GeoPoi nt \"scooterNumber\" : nu mber } Code 400 Code 404 Subscriptions Area of Servie AreaCreated AreaDeleted AreaShapeChanged ScooterAssignedToArea ScooterRemovedFromArea Trip TripStarted TripEnded Rent RentConfirmed RentStopped","title":"Drop Points Planning"},{"location":"API/v0/Insight/Drop%20Points%20Planning.html#drop-points-planning","text":"","title":"Drop Points Planning"},{"location":"API/v0/Insight/Drop%20Points%20Planning.html#api","text":"","title":"API"},{"location":"API/v0/Insight/Drop%20Points%20Planning.html#droppoints","text":"","title":"/DropPoints"},{"location":"API/v0/Insight/Drop%20Points%20Planning.html#get","text":"Returns the list of the best drop points Query Parameters - pageNum : number of requested page given the pageSize - pageSize : elements per page Response Code 200: paginated response { \"data\" : [ { \"id\" : s tr i n g //E nt i t yId } ] }","title":"GET"},{"location":"API/v0/Insight/Drop%20Points%20Planning.html#droppointsid","text":"URL Parameters - id : the EntityId that identifies the requested drop point.","title":"/DropPoints/{id}"},{"location":"API/v0/Insight/Drop%20Points%20Planning.html#get_1","text":"get the properties of an existing drop point Response Code 200: { \"id\" : s tr i n g , //E nt i t yId \"position\" : objec t , //GeoPoi nt \"scooterNumber\" : nu mber } Code 400 Code 404","title":"GET"},{"location":"API/v0/Insight/Drop%20Points%20Planning.html#subscriptions","text":"","title":"Subscriptions"},{"location":"API/v0/Insight/Drop%20Points%20Planning.html#area-of-servie","text":"AreaCreated AreaDeleted AreaShapeChanged ScooterAssignedToArea ScooterRemovedFromArea","title":"Area of Servie"},{"location":"API/v0/Insight/Drop%20Points%20Planning.html#trip","text":"TripStarted TripEnded","title":"Trip"},{"location":"API/v0/Insight/Drop%20Points%20Planning.html#rent","text":"RentConfirmed RentStopped","title":"Rent"},{"location":"API/v0/Rent/Rent%20Payment.html","text":"Rent Payment Outgoing Events RentAuthorized Fires when a rent is authorized { \"rentId\" : s tr i n g //E nt i t yId } RentNotAuthorized Fires when a rent is authorized { \"rentId\" : s tr i n g //E nt i t yId } CreditExhaustedForRent Fires when the credit isn't enough to continue the rent { \"rentId\" : s tr i n g //E nt i t yId } Subscriptions Rent RentRequested RentConfirmed RentStopped","title":"Rent Payment"},{"location":"API/v0/Rent/Rent%20Payment.html#rent-payment","text":"","title":"Rent Payment"},{"location":"API/v0/Rent/Rent%20Payment.html#outgoing-events","text":"","title":"Outgoing Events"},{"location":"API/v0/Rent/Rent%20Payment.html#rentauthorized","text":"Fires when a rent is authorized { \"rentId\" : s tr i n g //E nt i t yId }","title":"RentAuthorized"},{"location":"API/v0/Rent/Rent%20Payment.html#rentnotauthorized","text":"Fires when a rent is authorized { \"rentId\" : s tr i n g //E nt i t yId }","title":"RentNotAuthorized"},{"location":"API/v0/Rent/Rent%20Payment.html#creditexhaustedforrent","text":"Fires when the credit isn't enough to continue the rent { \"rentId\" : s tr i n g //E nt i t yId }","title":"CreditExhaustedForRent"},{"location":"API/v0/Rent/Rent%20Payment.html#subscriptions","text":"","title":"Subscriptions"},{"location":"API/v0/Rent/Rent%20Payment.html#rent","text":"RentRequested RentConfirmed RentStopped","title":"Rent"},{"location":"API/v0/Rent/Rent.html","text":"Rent API /rents GET Returns a list of Rents. Query Parameters - pageNum : number of requested page given the pageSize - pageSize : elements per page Response Code 200: paginated response { \"data\" : [ { \"id\" : s tr i n g //E nt i t yId } ] } /rents/{rentId} URL Parameters - rentId : the EntityId that identifies the requested rent GET Requests the end of a rent Response Code 201: { \"scooterId\" : s tr i n g , //E nt i t yId \"customerId\" : s tr i n g , //E nt i t yId \"rentId\" : s tr i n g , //E nt i t yId \"confirmed\" : boolea n , \"end\" : boolea n } Code 404 /scooter/{scooterId}/rent URL Parameters - scooterId : the EntityId that identifies the requested scooter POST Requests the start of a rent Body { \"customerId\" : s tr i n g //E nt i t yId } Response Code 201: { \"scooterId\" : s tr i n g , //E nt i t yId \"customerId\" : s tr i n g , //E nt i t yId \"rentId\" : s tr i n g , //E nt i t yId } Code 404 Code 400 /rents/stop/{rentId} URL Parameters - rentId : the EntityId that identifies the requested rent POST Requests the end of a rent Response Code 201: { \"rentId\" : s tr i n g , //E nt i t yId } Code 404 Outgoing Events RentRequested Fires when a rent is created but still not confirmed { \"rentId\" : s tr i n g , //E nt i t yId } RentConfirmed Fires when a rent is confirmed { /* TODO ci va nn o? \"scooterId\" : s tr i n g , //E nt i t yId \"customerId\" : s tr i n g , //E nt i t yId */ \"rentId\" : s tr i n g , //E nt i t yId \"confirm\" : nu mber //Times ta mp } RentStopped Fires when a rent is stopped for the reason specified in the body { \"rentId\" : s tr i n g , //E nt i t yId \"reason\" : s tr i n g , //Re nt E n dReaso n \"stop\" : nu mber //Times ta mp } Subscriptions ScooterData ScooterCreated ScooterDeleted Rent Payment RentAuthorized RentNotAuthorized CreditExhaustedForRent","title":"Rent"},{"location":"API/v0/Rent/Rent.html#rent","text":"","title":"Rent"},{"location":"API/v0/Rent/Rent.html#api","text":"","title":"API"},{"location":"API/v0/Rent/Rent.html#rents","text":"","title":"/rents"},{"location":"API/v0/Rent/Rent.html#get","text":"Returns a list of Rents. Query Parameters - pageNum : number of requested page given the pageSize - pageSize : elements per page Response Code 200: paginated response { \"data\" : [ { \"id\" : s tr i n g //E nt i t yId } ] }","title":"GET"},{"location":"API/v0/Rent/Rent.html#rentsrentid","text":"URL Parameters - rentId : the EntityId that identifies the requested rent","title":"/rents/{rentId}"},{"location":"API/v0/Rent/Rent.html#get_1","text":"Requests the end of a rent Response Code 201: { \"scooterId\" : s tr i n g , //E nt i t yId \"customerId\" : s tr i n g , //E nt i t yId \"rentId\" : s tr i n g , //E nt i t yId \"confirmed\" : boolea n , \"end\" : boolea n } Code 404","title":"GET"},{"location":"API/v0/Rent/Rent.html#scooterscooteridrent","text":"URL Parameters - scooterId : the EntityId that identifies the requested scooter","title":"/scooter/{scooterId}/rent"},{"location":"API/v0/Rent/Rent.html#post","text":"Requests the start of a rent Body { \"customerId\" : s tr i n g //E nt i t yId } Response Code 201: { \"scooterId\" : s tr i n g , //E nt i t yId \"customerId\" : s tr i n g , //E nt i t yId \"rentId\" : s tr i n g , //E nt i t yId } Code 404 Code 400","title":"POST"},{"location":"API/v0/Rent/Rent.html#rentsstoprentid","text":"URL Parameters - rentId : the EntityId that identifies the requested rent","title":"/rents/stop/{rentId}"},{"location":"API/v0/Rent/Rent.html#post_1","text":"Requests the end of a rent Response Code 201: { \"rentId\" : s tr i n g , //E nt i t yId } Code 404","title":"POST"},{"location":"API/v0/Rent/Rent.html#outgoing-events","text":"","title":"Outgoing Events"},{"location":"API/v0/Rent/Rent.html#rentrequested","text":"Fires when a rent is created but still not confirmed { \"rentId\" : s tr i n g , //E nt i t yId }","title":"RentRequested"},{"location":"API/v0/Rent/Rent.html#rentconfirmed","text":"Fires when a rent is confirmed { /* TODO ci va nn o? \"scooterId\" : s tr i n g , //E nt i t yId \"customerId\" : s tr i n g , //E nt i t yId */ \"rentId\" : s tr i n g , //E nt i t yId \"confirm\" : nu mber //Times ta mp }","title":"RentConfirmed"},{"location":"API/v0/Rent/Rent.html#rentstopped","text":"Fires when a rent is stopped for the reason specified in the body { \"rentId\" : s tr i n g , //E nt i t yId \"reason\" : s tr i n g , //Re nt E n dReaso n \"stop\" : nu mber //Times ta mp }","title":"RentStopped"},{"location":"API/v0/Rent/Rent.html#subscriptions","text":"","title":"Subscriptions"},{"location":"API/v0/Rent/Rent.html#scooterdata","text":"ScooterCreated ScooterDeleted","title":"ScooterData"},{"location":"API/v0/Rent/Rent.html#rent-payment","text":"RentAuthorized RentNotAuthorized CreditExhaustedForRent","title":"Rent Payment"},{"location":"API/v0/Rent/Trip.html","text":"Trip API /trips GET Returns a list of Trips. Query Parameters - pageNum : number of requested page given the pageSize - pageSize : elements per page Response Code 200: paginated response { \"data\" : [ { \"id\" : s tr i n g //E nt i t yId } ] } POST Creates a new Trip. Body { \"rentId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g , //E nt i t yId } Response Code 201: { \"id\" : s tr i n g , //E nt i t yId } Code 400 /trips/{id} URL Parameters - id : the EntityId that identifies the requested trip. GET get the properties of an existing trip Response Code 200: { \"id\" : s tr i n g , //E nt i t yId //TODO ges t ire s tart s t op come TripPoi nt ? \"start\" : objec t , //TripPoi nt \"stop\" : objec t , //TripPoi nt \"travelledDistance\" : nu mber //Dis tan ce } Code 400 Code 404 Outgoing Events TripStarted Fires when a new trip starts { \"id\" : s tr i n g , //E nt i t yId //TODO ges t ire s tart s t op come TripPoi nt ? \"start\" : objec t , //TripPoi nt } TripEnded Fires when a new trip ends { \"id\" : s tr i n g , //E nt i t yId //TODO ges t ire s tart s t op come TripPoi nt ? \"stop\" : objec t , //TripPoi nt } Subscriptions Scooter Data ScooterCreated ScooterDeleted Rent RentRequest RentConfirmed RentStopped","title":"Trip"},{"location":"API/v0/Rent/Trip.html#trip","text":"","title":"Trip"},{"location":"API/v0/Rent/Trip.html#api","text":"","title":"API"},{"location":"API/v0/Rent/Trip.html#trips","text":"","title":"/trips"},{"location":"API/v0/Rent/Trip.html#get","text":"Returns a list of Trips. Query Parameters - pageNum : number of requested page given the pageSize - pageSize : elements per page Response Code 200: paginated response { \"data\" : [ { \"id\" : s tr i n g //E nt i t yId } ] }","title":"GET"},{"location":"API/v0/Rent/Trip.html#post","text":"Creates a new Trip. Body { \"rentId\" : s tr i n g , //E nt i t yId \"scooterId\" : s tr i n g , //E nt i t yId } Response Code 201: { \"id\" : s tr i n g , //E nt i t yId } Code 400","title":"POST"},{"location":"API/v0/Rent/Trip.html#tripsid","text":"URL Parameters - id : the EntityId that identifies the requested trip.","title":"/trips/{id}"},{"location":"API/v0/Rent/Trip.html#get_1","text":"get the properties of an existing trip Response Code 200: { \"id\" : s tr i n g , //E nt i t yId //TODO ges t ire s tart s t op come TripPoi nt ? \"start\" : objec t , //TripPoi nt \"stop\" : objec t , //TripPoi nt \"travelledDistance\" : nu mber //Dis tan ce } Code 400 Code 404","title":"GET"},{"location":"API/v0/Rent/Trip.html#outgoing-events","text":"","title":"Outgoing Events"},{"location":"API/v0/Rent/Trip.html#tripstarted","text":"Fires when a new trip starts { \"id\" : s tr i n g , //E nt i t yId //TODO ges t ire s tart s t op come TripPoi nt ? \"start\" : objec t , //TripPoi nt }","title":"TripStarted"},{"location":"API/v0/Rent/Trip.html#tripended","text":"Fires when a new trip ends { \"id\" : s tr i n g , //E nt i t yId //TODO ges t ire s tart s t op come TripPoi nt ? \"stop\" : objec t , //TripPoi nt }","title":"TripEnded"},{"location":"API/v0/Rent/Trip.html#subscriptions","text":"","title":"Subscriptions"},{"location":"API/v0/Rent/Trip.html#scooter-data","text":"ScooterCreated ScooterDeleted","title":"Scooter Data"},{"location":"API/v0/Rent/Trip.html#rent","text":"RentRequest RentConfirmed RentStopped","title":"Rent"},{"location":"API/v1/index.html","text":"API v1 TODO - Link here","title":"API v1"},{"location":"API/v1/index.html#api-v1","text":"TODO - Link here","title":"API v1"},{"location":"architecture-design/SUMMARY.html","text":"Architectural Map Service Architecture","title":"SUMMARY"},{"location":"architecture-design/architectural-map.html","text":"Architectural map This section contains an overview of the final version of the system as it has been designed for implementation, giving an holistic view of the developed components and their relationships with each other. Components of the system can be categorized in: Microservices : standalone services that encapsulate their state and provide a well defined set of functionalities accessible through their public interface. Microservices can communicate with each other through events or asynchronous commands. Azure services : instances of services offered by the Microsoft Azure cloud infrastructure, providing a wide range of features that need to be integrated with other services. Functions : stateless instances that are typically used to translate and facilitate communication among other components of the system. They fit particularly well in the serverless computation model, and are therefore chosen to be implemented through Azure Functions . An important thing to note is that in Azure, the minimal unit of deployment is a Function App , which can host multiple functions with different tasks that scale together. The following sections use the term \"function\" to indicate an Azure Function App, that can therefore contain multiple instances of serverless functions. Devices : computational resources belonging to the physical world. They are embedded IoT devices onto the electric scooters managed by the system. The diagrams in the sections below show the communication between each pair of components, classifying it in: Synchronous updates ( Updates arrow) : commands sent over synchronous media, like HTTP or RPC. Asynchronous commands ( Sends commands arrow) : commands sent in an asynchronous way, typically using message queues. Publish subscribe ( Exposes topic & Observes arrows) : events are published on topics and observed by subscribers of that topic, using asynchronous messaging. E-Scooter subdomain This subdomain contains all the services and functions that deal with the scooter lifecycle and with the exchange of information between the physical devices and the system. Since the scooter data context has the authority over the identity of the scooters and, thus, over their existence in the system, we planned to build it as a microservice. However, for this prototypal implementation, due to the limited time, it was mocked via a GUI that mimics its behavior exposing the scooter lifecycle interface (i.e. notifying the creation/deletion of scooters). On the other hand, the Scooter Monitor & Control context deals with the communication with the physical world. Its access point to the real world has been chosen to be realized via the Azure IoT Hub , a service specifically designed to be the pivot point between the cloud and IoT devices. The IoT Hub can keep track of a large set of entities (denoted as Devices ), each with its own identity. Each device has two sets of properties to hold state: (i) Desired properties , used by the cloud infrastructure to communicate the desired state for the device; (ii) Reported properties , used by the device to communicate its actual state (which can be different from the desired one). Furthermore, each device can emit a series of frequent events (almost a continuous stream) denoted as Telemetry . These are meant for continuously changing properties (like position, speed or battery level, in the e-scooter domain). New scooters that are registered to the system are recorded as devices inside the IoT Hub thanks to the Manage Devices function, relying on the scooter lifecycle topic. After registration, the scooter can start to be monitored and/or controlled by the system. The physical actuation of control policies is demanded to the Scooter Control function, which receives asynchronous commands from other components in order for them to be propagated to the physical devices via the IoT Hub. This commands, among others, include the operations to lock / unlock scooters, for example when a customer rents one. The IoT Hub can also be configured to emit events whenever a telemetry is sent or whenever a reported property changes. This feature has been exploited to integrate it with the rest of the ecosystem. In particular, the cloud service emits events when properties like locked or standby change. In order to have a simpler interface for reported properties updates, the Scooter Monitor function has been put in between the Hub and the rest of the system, to translate them into events tailored for the e-scooter domain. User subdomain Being a generic subdomain, the team decided to have the User subdomain be implemented using an off-the-shelf package. Therefore, the team opted to mock the interfaces of this subdomain that were needed by other components in other subdomains, namely the Customer lifecycle topic. This is the topic exposed by the designed Customer Microservice to let others know about customers signing up to the system or customers unregistering from it. Like the scooter data microservice, this was implemented via a GUI emitting the events for other services to observe. Rent subdomain The rent subdomain deals with the functionalities that allow customers to rent scooters, along with side features reserved to assistants and admins of the service. The core of this subdomain is the Rent Microservice , which provides clients with an interface to start and stop rents as a customer, or to enable or disable scooters as an assistant or as an admin. To work properly, it needs to know about the existing customers and scooters, which is done by subscribing to the Scooter Lifecycle , Scooter Status and Customer Lifecycle topics. This service is also responsible for the locking and unlocking of scooters according to the lifecycle of the related rents. Since these operations are offered by the Scooter Control function, the rent service only needs to send asynchronous commands to it when necessary. The Rent Microservice does not directly deal with the payment of the rides, but delegates this responsibility to another microservice from a different bounded context, the Rent Payment Service . Since payments are assumed to use virtual currency managed by the system, this service needs to ensure that: (i) a renting customer has enough credit to start a rent, that is authorizing or rejecting the rent; (ii) a rent is stopped when a customer's credit runs out. This collaboration between the two services is carried out via an exchange of events using the Rent Lifecycle and Rent Payment Events topics. Due to the limited time though, the Rent Payment service was mocked with a function that always authorizes rents when they are requested. Azure Digital Twins Since this project is about the exploration of the digital twins paradigm, the team decided to adopt a standard and production-ready solution to keep track of the real-time state of the system. This gives clients the possibility to query it in arbitrary ways. The solution of choice was Azure Digital Twins , which has all the required features. Azure Digital Twins allows developers to define a set of DTDL models to define real-world assets as twins along with their properties and the relationships they can have with other digital twins. Once the models are uploaded to the Azure Digital Twins instance, external agents can use its API and/or SDK to run CRUD operations on both digital twins and relationships, in order to control the digital twin graph . EScooter DTDL Models DTDL models of EScooter digital twins can be found in the twins-models repository . Azure Digital Twins can be easily integrated with other cloud services (including the IoT Hub) using Azure Functions. In particular, the team planned to develop a group of functions to create digital twins for the scooters and the customers managed by the rest of the system and also to keep them up to date with the real-time state.","title":"Architectural Map"},{"location":"architecture-design/architectural-map.html#architectural-map","text":"This section contains an overview of the final version of the system as it has been designed for implementation, giving an holistic view of the developed components and their relationships with each other. Components of the system can be categorized in: Microservices : standalone services that encapsulate their state and provide a well defined set of functionalities accessible through their public interface. Microservices can communicate with each other through events or asynchronous commands. Azure services : instances of services offered by the Microsoft Azure cloud infrastructure, providing a wide range of features that need to be integrated with other services. Functions : stateless instances that are typically used to translate and facilitate communication among other components of the system. They fit particularly well in the serverless computation model, and are therefore chosen to be implemented through Azure Functions . An important thing to note is that in Azure, the minimal unit of deployment is a Function App , which can host multiple functions with different tasks that scale together. The following sections use the term \"function\" to indicate an Azure Function App, that can therefore contain multiple instances of serverless functions. Devices : computational resources belonging to the physical world. They are embedded IoT devices onto the electric scooters managed by the system. The diagrams in the sections below show the communication between each pair of components, classifying it in: Synchronous updates ( Updates arrow) : commands sent over synchronous media, like HTTP or RPC. Asynchronous commands ( Sends commands arrow) : commands sent in an asynchronous way, typically using message queues. Publish subscribe ( Exposes topic & Observes arrows) : events are published on topics and observed by subscribers of that topic, using asynchronous messaging.","title":"Architectural map"},{"location":"architecture-design/architectural-map.html#e-scooter-subdomain","text":"This subdomain contains all the services and functions that deal with the scooter lifecycle and with the exchange of information between the physical devices and the system. Since the scooter data context has the authority over the identity of the scooters and, thus, over their existence in the system, we planned to build it as a microservice. However, for this prototypal implementation, due to the limited time, it was mocked via a GUI that mimics its behavior exposing the scooter lifecycle interface (i.e. notifying the creation/deletion of scooters). On the other hand, the Scooter Monitor & Control context deals with the communication with the physical world. Its access point to the real world has been chosen to be realized via the Azure IoT Hub , a service specifically designed to be the pivot point between the cloud and IoT devices. The IoT Hub can keep track of a large set of entities (denoted as Devices ), each with its own identity. Each device has two sets of properties to hold state: (i) Desired properties , used by the cloud infrastructure to communicate the desired state for the device; (ii) Reported properties , used by the device to communicate its actual state (which can be different from the desired one). Furthermore, each device can emit a series of frequent events (almost a continuous stream) denoted as Telemetry . These are meant for continuously changing properties (like position, speed or battery level, in the e-scooter domain). New scooters that are registered to the system are recorded as devices inside the IoT Hub thanks to the Manage Devices function, relying on the scooter lifecycle topic. After registration, the scooter can start to be monitored and/or controlled by the system. The physical actuation of control policies is demanded to the Scooter Control function, which receives asynchronous commands from other components in order for them to be propagated to the physical devices via the IoT Hub. This commands, among others, include the operations to lock / unlock scooters, for example when a customer rents one. The IoT Hub can also be configured to emit events whenever a telemetry is sent or whenever a reported property changes. This feature has been exploited to integrate it with the rest of the ecosystem. In particular, the cloud service emits events when properties like locked or standby change. In order to have a simpler interface for reported properties updates, the Scooter Monitor function has been put in between the Hub and the rest of the system, to translate them into events tailored for the e-scooter domain.","title":"E-Scooter subdomain"},{"location":"architecture-design/architectural-map.html#user-subdomain","text":"Being a generic subdomain, the team decided to have the User subdomain be implemented using an off-the-shelf package. Therefore, the team opted to mock the interfaces of this subdomain that were needed by other components in other subdomains, namely the Customer lifecycle topic. This is the topic exposed by the designed Customer Microservice to let others know about customers signing up to the system or customers unregistering from it. Like the scooter data microservice, this was implemented via a GUI emitting the events for other services to observe.","title":"User subdomain"},{"location":"architecture-design/architectural-map.html#rent-subdomain","text":"The rent subdomain deals with the functionalities that allow customers to rent scooters, along with side features reserved to assistants and admins of the service. The core of this subdomain is the Rent Microservice , which provides clients with an interface to start and stop rents as a customer, or to enable or disable scooters as an assistant or as an admin. To work properly, it needs to know about the existing customers and scooters, which is done by subscribing to the Scooter Lifecycle , Scooter Status and Customer Lifecycle topics. This service is also responsible for the locking and unlocking of scooters according to the lifecycle of the related rents. Since these operations are offered by the Scooter Control function, the rent service only needs to send asynchronous commands to it when necessary. The Rent Microservice does not directly deal with the payment of the rides, but delegates this responsibility to another microservice from a different bounded context, the Rent Payment Service . Since payments are assumed to use virtual currency managed by the system, this service needs to ensure that: (i) a renting customer has enough credit to start a rent, that is authorizing or rejecting the rent; (ii) a rent is stopped when a customer's credit runs out. This collaboration between the two services is carried out via an exchange of events using the Rent Lifecycle and Rent Payment Events topics. Due to the limited time though, the Rent Payment service was mocked with a function that always authorizes rents when they are requested.","title":"Rent subdomain"},{"location":"architecture-design/architectural-map.html#azure-digital-twins","text":"Since this project is about the exploration of the digital twins paradigm, the team decided to adopt a standard and production-ready solution to keep track of the real-time state of the system. This gives clients the possibility to query it in arbitrary ways. The solution of choice was Azure Digital Twins , which has all the required features. Azure Digital Twins allows developers to define a set of DTDL models to define real-world assets as twins along with their properties and the relationships they can have with other digital twins. Once the models are uploaded to the Azure Digital Twins instance, external agents can use its API and/or SDK to run CRUD operations on both digital twins and relationships, in order to control the digital twin graph . EScooter DTDL Models DTDL models of EScooter digital twins can be found in the twins-models repository . Azure Digital Twins can be easily integrated with other cloud services (including the IoT Hub) using Azure Functions. In particular, the team planned to develop a group of functions to create digital twins for the scooters and the customers managed by the rest of the system and also to keep them up to date with the real-time state.","title":"Azure Digital Twins"},{"location":"architecture-design/service-architecture.html","text":"Service Architecture Clean architecture Each service of the system follows a strict architecture that splits it into a series of layers, following the principles of the Clean Architecture . Since there are several different opinions and views on what the clean architecture should look like, the team came up with its own interpretation of the layers contained in each service and of their relationships with each other. While the details of each layer are discussed in the next sections, the diagram below shows a holistic view the resulting design. Domain Layer This is the core layer of any service and it is responsible of defining the business rules of the context containing the service. It contains the definition of the entities and value objects belonging to the service and their associated behaviors. Entities and value objects are then organized into aggregates enforcing consistency boundaries over them. This layer can also define high level processes or constraints that are encapsulated inside domain services . Entities and domain services can notify the occurrence of any relevant state change using domain events , which are defined here but handled within the application layer . Application Layer Defines a collection of use cases exposed by the service and the actions to be executed for each of those through a series of handlers that interact with the domain and infrastructure layers to carry out those actions. Handlers can also be used to run business logic when events occur in the domain or to integrate with other services/contexts using external events . External events are a projection of domain events that is propagated to other contexts, useful to hide inner domain details, therefore making contexts less coupled. Furthermore, this layer is responsible of authorization , transactional data access and communication with external services. To keep the application logic as clean as possible, infrastructural concerns like databases, event queues or protocols are kept away from the application layer through infrastructure interfaces declared here, but implemented by the infrastructure layer itself. Infrastructure Layer This layer holds the concrete implementation of the interfaces declared by the Application Layer or by the Domain Layer . These interfaces typically model behavior related to persistence , external communication and other utility services required by other layers. Web Layer Implements the entry point that clients of the service use to make requests. Clients can make requests using the REST API exposed by each microservice, therefore this layer defines the REST endpoints that the service supports along with their interface. To that purpose, each service contains a series of DTOs (Data Transfer Objects, i.e. the objects modeling the format of communication with clients) to formally represent the interface of each endpoint. Lastly, this layer is responsible of managing the authentication process to determine the identity of the agent making requests to the service.","title":"Service Architecture"},{"location":"architecture-design/service-architecture.html#service-architecture","text":"","title":"Service Architecture"},{"location":"architecture-design/service-architecture.html#clean-architecture","text":"Each service of the system follows a strict architecture that splits it into a series of layers, following the principles of the Clean Architecture . Since there are several different opinions and views on what the clean architecture should look like, the team came up with its own interpretation of the layers contained in each service and of their relationships with each other. While the details of each layer are discussed in the next sections, the diagram below shows a holistic view the resulting design.","title":"Clean architecture"},{"location":"architecture-design/service-architecture.html#domain-layer","text":"This is the core layer of any service and it is responsible of defining the business rules of the context containing the service. It contains the definition of the entities and value objects belonging to the service and their associated behaviors. Entities and value objects are then organized into aggregates enforcing consistency boundaries over them. This layer can also define high level processes or constraints that are encapsulated inside domain services . Entities and domain services can notify the occurrence of any relevant state change using domain events , which are defined here but handled within the application layer .","title":"Domain Layer"},{"location":"architecture-design/service-architecture.html#application-layer","text":"Defines a collection of use cases exposed by the service and the actions to be executed for each of those through a series of handlers that interact with the domain and infrastructure layers to carry out those actions. Handlers can also be used to run business logic when events occur in the domain or to integrate with other services/contexts using external events . External events are a projection of domain events that is propagated to other contexts, useful to hide inner domain details, therefore making contexts less coupled. Furthermore, this layer is responsible of authorization , transactional data access and communication with external services. To keep the application logic as clean as possible, infrastructural concerns like databases, event queues or protocols are kept away from the application layer through infrastructure interfaces declared here, but implemented by the infrastructure layer itself.","title":"Application Layer"},{"location":"architecture-design/service-architecture.html#infrastructure-layer","text":"This layer holds the concrete implementation of the interfaces declared by the Application Layer or by the Domain Layer . These interfaces typically model behavior related to persistence , external communication and other utility services required by other layers.","title":"Infrastructure Layer"},{"location":"architecture-design/service-architecture.html#web-layer","text":"Implements the entry point that clients of the service use to make requests. Clients can make requests using the REST API exposed by each microservice, therefore this layer defines the REST endpoints that the service supports along with their interface. To that purpose, each service contains a series of DTOs (Data Transfer Objects, i.e. the objects modeling the format of communication with clients) to formally represent the interface of each endpoint. Lastly, this layer is responsible of managing the authentication process to determine the identity of the agent making requests to the service.","title":"Web Layer"},{"location":"domain-analysis/SUMMARY.html","text":"Bounded Contexts Context Mapping Domain Models","title":"SUMMARY"},{"location":"domain-analysis/bounded-contexts.html","text":"Bounded Contexts After understanding the domain with the domain experts the team proceeded with the identification of the different subdomains and the bounded contexts within it. The analysis brought to the definition of the following contexts that were later analyzed to generate the context map in order to understand the relationships between each context and move towards a definition of the different software components that define the architecture of the whole system. E-Scooter Subdomain Core Subdomain Scooter Control & Monitor Context One of the core contexts. Responsible for keeping track of scooter positions, battery level and other useful data coming from the physical devices. Provides the operation of locking and unlocking scooters to other contexts and it's considered the ground truth on the scooter settings/control data. Also responsible for defining control policies and apply them by operating on the physical devices, like power saving, and enforcing speed limits that could depend on the scooter physical state. Responsible for physical actuation of all the remote operations on the scooter. Area of Service Context Keeps track of service areas, scooter-to-area bindings and scooter positions in order to detect when a scooter is crossing the area boundary and notify the other contexts when that happens. Scooter Data Context Storage of e-scooters technical and logical static information, like ID, serial number, dimensions, weight... Is the ground truth on the identity of a scooter. Rent Subdomain Core Subdomain Rent Context Manages the renting operations including storing data on which scooters are rented and by whom. Provides the interface for searching and renting scooters. Manages the logic enabling and disabling of a scooter and provides an interface to do that. Trip Context Data collection about trips done by all customers such as starting points, duration, travelled kilometers. Rent Payment Context Responsible for managing the payment policy for customer rents. Authorizes the renting operation by checking in with the payment context. Insight Subdomain Core Subdomain Drop points Planning Context Exploits usage data from other contexts to compute drop point locations or suggestions. Stores data of scooter searches from users. Payment Subdomain Supporting Subdomain Payment Context Manages all customers in-app transactions, virtual currency, and triggers real-world transactions. User Subdomain Generic Subdomain Customer Context Keeps track of customers anagraphic data. Authentication Context Manages login data and role based authentication for all people that use the service, including admins, assistants and customers.","title":"Bounded Contexts"},{"location":"domain-analysis/bounded-contexts.html#bounded-contexts","text":"After understanding the domain with the domain experts the team proceeded with the identification of the different subdomains and the bounded contexts within it. The analysis brought to the definition of the following contexts that were later analyzed to generate the context map in order to understand the relationships between each context and move towards a definition of the different software components that define the architecture of the whole system.","title":"Bounded Contexts"},{"location":"domain-analysis/bounded-contexts.html#e-scooter-subdomain","text":"Core Subdomain","title":"E-Scooter Subdomain"},{"location":"domain-analysis/bounded-contexts.html#scooter-control-monitor-context","text":"One of the core contexts. Responsible for keeping track of scooter positions, battery level and other useful data coming from the physical devices. Provides the operation of locking and unlocking scooters to other contexts and it's considered the ground truth on the scooter settings/control data. Also responsible for defining control policies and apply them by operating on the physical devices, like power saving, and enforcing speed limits that could depend on the scooter physical state. Responsible for physical actuation of all the remote operations on the scooter.","title":"Scooter Control &amp; Monitor Context"},{"location":"domain-analysis/bounded-contexts.html#area-of-service-context","text":"Keeps track of service areas, scooter-to-area bindings and scooter positions in order to detect when a scooter is crossing the area boundary and notify the other contexts when that happens.","title":"Area of Service Context"},{"location":"domain-analysis/bounded-contexts.html#scooter-data-context","text":"Storage of e-scooters technical and logical static information, like ID, serial number, dimensions, weight... Is the ground truth on the identity of a scooter.","title":"Scooter Data Context"},{"location":"domain-analysis/bounded-contexts.html#rent-subdomain","text":"Core Subdomain","title":"Rent Subdomain"},{"location":"domain-analysis/bounded-contexts.html#rent-context","text":"Manages the renting operations including storing data on which scooters are rented and by whom. Provides the interface for searching and renting scooters. Manages the logic enabling and disabling of a scooter and provides an interface to do that.","title":"Rent Context"},{"location":"domain-analysis/bounded-contexts.html#trip-context","text":"Data collection about trips done by all customers such as starting points, duration, travelled kilometers.","title":"Trip Context"},{"location":"domain-analysis/bounded-contexts.html#rent-payment-context","text":"Responsible for managing the payment policy for customer rents. Authorizes the renting operation by checking in with the payment context.","title":"Rent Payment Context"},{"location":"domain-analysis/bounded-contexts.html#insight-subdomain","text":"Core Subdomain","title":"Insight Subdomain"},{"location":"domain-analysis/bounded-contexts.html#drop-points-planning-context","text":"Exploits usage data from other contexts to compute drop point locations or suggestions. Stores data of scooter searches from users.","title":"Drop points Planning Context"},{"location":"domain-analysis/bounded-contexts.html#payment-subdomain","text":"Supporting Subdomain","title":"Payment Subdomain"},{"location":"domain-analysis/bounded-contexts.html#payment-context","text":"Manages all customers in-app transactions, virtual currency, and triggers real-world transactions.","title":"Payment Context"},{"location":"domain-analysis/bounded-contexts.html#user-subdomain","text":"Generic Subdomain","title":"User Subdomain"},{"location":"domain-analysis/bounded-contexts.html#customer-context","text":"Keeps track of customers anagraphic data.","title":"Customer Context"},{"location":"domain-analysis/bounded-contexts.html#authentication-context","text":"Manages login data and role based authentication for all people that use the service, including admins, assistants and customers.","title":"Authentication Context"},{"location":"domain-analysis/context-mapping.html","text":"Context Mapping The context map below shows all the different context in the scooter service domain. Five subdomain are identified: E-Scooter Subdomain : manages all the logic concerning the physical scooters Rent Subdomain : manages all the logic concerning the rent process from the financial policies to the storage of trips' data Insight Subdomain : concerns the elaboration of the best possible drop points for scooters to improve the quality of service Payment Subdomain : manages the logic of real-world payments by integrating with a legacy system User Subdomain : contains the anagraphical information of the service users and provide authentication The relationships between contexts are explicitated through the representation of interfaces that are exposed in to allow the sharing of information in the system. Basically all the relationships between services are of type conformist since the context which exposes the interface holds the truth source about that data and it's responsible to decide what to share externally and how. The payment context is an anti-corruption layer on top of the existing legacy system that manages real world transactions. Context Map","title":"Context Mapping"},{"location":"domain-analysis/context-mapping.html#context-mapping","text":"The context map below shows all the different context in the scooter service domain. Five subdomain are identified: E-Scooter Subdomain : manages all the logic concerning the physical scooters Rent Subdomain : manages all the logic concerning the rent process from the financial policies to the storage of trips' data Insight Subdomain : concerns the elaboration of the best possible drop points for scooters to improve the quality of service Payment Subdomain : manages the logic of real-world payments by integrating with a legacy system User Subdomain : contains the anagraphical information of the service users and provide authentication The relationships between contexts are explicitated through the representation of interfaces that are exposed in to allow the sharing of information in the system. Basically all the relationships between services are of type conformist since the context which exposes the interface holds the truth source about that data and it's responsible to decide what to share externally and how. The payment context is an anti-corruption layer on top of the existing legacy system that manages real world transactions.","title":"Context Mapping"},{"location":"domain-analysis/context-mapping.html#context-map","text":"","title":"Context Map"},{"location":"domain-analysis/domain-models/common/common-types.html","text":"Common Types This section contains a set of value objects used throughout the domain models of the identified bounded contexts, to avoid repeating them in each diagram. Result Represents the outcome of a domain operation, which may result in a success (in which case the result contains a value of type T) or in a failure (which results in a DomainError ). EntityId Represents how the identity of entities is passed in the system enabling the possibility to distinguish between one another of the same kind. GeoPoint Defines a geographical coordinate as a 2D value (using latitude and longitude). Constraints : \\(-90 < latitude.value < 90\\) \\(-180 < longitude.value < 180\\) Distance Represents a linear, non-directed (meaning an absolute value) distance. Constraints : \\(kilometers \\geq 0\\) Timestamp Represents a unique point in time, independent of any time zone. value is the number of milliseconds passed since 01/01/1970 00:00:00 (Epoch). Nothing Represents the absence of any value, nothingness .","title":"Common Types"},{"location":"domain-analysis/domain-models/common/common-types.html#common-types","text":"This section contains a set of value objects used throughout the domain models of the identified bounded contexts, to avoid repeating them in each diagram.","title":"Common Types"},{"location":"domain-analysis/domain-models/common/common-types.html#result","text":"Represents the outcome of a domain operation, which may result in a success (in which case the result contains a value of type T) or in a failure (which results in a DomainError ).","title":"Result"},{"location":"domain-analysis/domain-models/common/common-types.html#entityid","text":"Represents how the identity of entities is passed in the system enabling the possibility to distinguish between one another of the same kind.","title":"EntityId"},{"location":"domain-analysis/domain-models/common/common-types.html#geopoint","text":"Defines a geographical coordinate as a 2D value (using latitude and longitude). Constraints : \\(-90 < latitude.value < 90\\) \\(-180 < longitude.value < 180\\)","title":"GeoPoint"},{"location":"domain-analysis/domain-models/common/common-types.html#distance","text":"Represents a linear, non-directed (meaning an absolute value) distance. Constraints : \\(kilometers \\geq 0\\)","title":"Distance"},{"location":"domain-analysis/domain-models/common/common-types.html#timestamp","text":"Represents a unique point in time, independent of any time zone. value is the number of milliseconds passed since 01/01/1970 00:00:00 (Epoch).","title":"Timestamp"},{"location":"domain-analysis/domain-models/common/common-types.html#nothing","text":"Represents the absence of any value, nothingness .","title":"Nothing"},{"location":"domain-analysis/domain-models/e-scooter/area-of-service.html","text":"Area of Service Domain Model Class Diagram Domain Events AreaCreated : emitted when an area is created AreaDeleted : emitted when an area is deleted ScooterAssignedToArea : emitted when a scooter is set to belong to a certain area of service. ScooterRemovedFromArea : emitted when a scooter is set to not belong to any area. AreaShapeChanged : emitted when the shape of an area of service is changed. ScooterWentOutsideArea : emitted when a scooter that belongs to an area is moved outside of its shape. ScooterWentInsideArea : emitted when a scooter returns inside its area of service after having moved out.","title":"Area of Service Domain Model"},{"location":"domain-analysis/domain-models/e-scooter/area-of-service.html#area-of-service-domain-model","text":"","title":"Area of Service Domain Model"},{"location":"domain-analysis/domain-models/e-scooter/area-of-service.html#class-diagram","text":"","title":"Class Diagram"},{"location":"domain-analysis/domain-models/e-scooter/area-of-service.html#domain-events","text":"AreaCreated : emitted when an area is created AreaDeleted : emitted when an area is deleted ScooterAssignedToArea : emitted when a scooter is set to belong to a certain area of service. ScooterRemovedFromArea : emitted when a scooter is set to not belong to any area. AreaShapeChanged : emitted when the shape of an area of service is changed. ScooterWentOutsideArea : emitted when a scooter that belongs to an area is moved outside of its shape. ScooterWentInsideArea : emitted when a scooter returns inside its area of service after having moved out.","title":"Domain Events"},{"location":"domain-analysis/domain-models/e-scooter/scooter-control.html","text":"Scooter Control & Monitor Domain Model Class Diagram Details Duration Constraints : \\(milliseconds > 0\\) Speed Constraints : \\(metersPerSecond = kilometersPerHour / 3.6\\) \\(metersPerSecond \\geq 0\\) BatteryLevel Constraints : \\(0 \\leq percentage \\leq 100\\) Note If the scooter goes under standby, speed limits imposed by Scooter Control are ignored. Rules A scooter has some properties that an employee can set to alter its behavior: desiredMaxSpeed : the maximum speed a scooter can reach at any moment; powerSavingMaxSpeed : the maximum speed a scooter can reach while in power saving mode; powerSavingThreshold : the battery level below which the scooter goes in power saving mode. The policy of the scooters dictate that, at any moment, the speed of a scooter should be below the desired max speed. Also, while in power saving mode, the scooter must also obey to the powerSavingMaxSpeed rule. Therefore, at any moment the real maximum speed can be calculated as: desiredMaxSpeed , if the scooter is in active mode. min(desiredMaxSpeed, powerSavingMaxSpeed) , otherwise. Furthermore, a scooter can at any moment go in standby mode. This behavior is dictated by the hardware mounted on the scooter itself. The system reacts to the switch by notyfing all services so that polices can be applied. Domain Events ScooterStatusChanged : emitted after scooter status updates (namely at least one of updateFrequency, locked, maxSpeed or standby). TelemetryUpdate : emitted periodically (and frequently) with scooter telemetry updates (namely the current value of the position, battery and speed properties).","title":"Scooter Control & Monitor Domain Model"},{"location":"domain-analysis/domain-models/e-scooter/scooter-control.html#scooter-control-monitor-domain-model","text":"","title":"Scooter Control &amp; Monitor Domain Model"},{"location":"domain-analysis/domain-models/e-scooter/scooter-control.html#class-diagram","text":"","title":"Class Diagram"},{"location":"domain-analysis/domain-models/e-scooter/scooter-control.html#details","text":"","title":"Details"},{"location":"domain-analysis/domain-models/e-scooter/scooter-control.html#duration","text":"Constraints : \\(milliseconds > 0\\)","title":"Duration"},{"location":"domain-analysis/domain-models/e-scooter/scooter-control.html#speed","text":"Constraints : \\(metersPerSecond = kilometersPerHour / 3.6\\) \\(metersPerSecond \\geq 0\\)","title":"Speed"},{"location":"domain-analysis/domain-models/e-scooter/scooter-control.html#batterylevel","text":"Constraints : \\(0 \\leq percentage \\leq 100\\) Note If the scooter goes under standby, speed limits imposed by Scooter Control are ignored.","title":"BatteryLevel"},{"location":"domain-analysis/domain-models/e-scooter/scooter-control.html#rules","text":"A scooter has some properties that an employee can set to alter its behavior: desiredMaxSpeed : the maximum speed a scooter can reach at any moment; powerSavingMaxSpeed : the maximum speed a scooter can reach while in power saving mode; powerSavingThreshold : the battery level below which the scooter goes in power saving mode. The policy of the scooters dictate that, at any moment, the speed of a scooter should be below the desired max speed. Also, while in power saving mode, the scooter must also obey to the powerSavingMaxSpeed rule. Therefore, at any moment the real maximum speed can be calculated as: desiredMaxSpeed , if the scooter is in active mode. min(desiredMaxSpeed, powerSavingMaxSpeed) , otherwise. Furthermore, a scooter can at any moment go in standby mode. This behavior is dictated by the hardware mounted on the scooter itself. The system reacts to the switch by notyfing all services so that polices can be applied.","title":"Rules"},{"location":"domain-analysis/domain-models/e-scooter/scooter-control.html#domain-events","text":"ScooterStatusChanged : emitted after scooter status updates (namely at least one of updateFrequency, locked, maxSpeed or standby). TelemetryUpdate : emitted periodically (and frequently) with scooter telemetry updates (namely the current value of the position, battery and speed properties).","title":"Domain Events"},{"location":"domain-analysis/domain-models/e-scooter/scooter-data.html","text":"Scooter Data Domain Model Class Diagram Details Weight Constraints : \\(kilograms > 0\\) Name Constraints : value must not be empty SerialNumber Constraints value matches ^[A-Za-z0-9-]+$ Domain events ScooterCreated : emitted when a new scooter is registered to the system. ScooterDeleted : emitted when a scooter is removed from the system.","title":"Scooter Data Domain Model"},{"location":"domain-analysis/domain-models/e-scooter/scooter-data.html#scooter-data-domain-model","text":"","title":"Scooter Data Domain Model"},{"location":"domain-analysis/domain-models/e-scooter/scooter-data.html#class-diagram","text":"","title":"Class Diagram"},{"location":"domain-analysis/domain-models/e-scooter/scooter-data.html#details","text":"","title":"Details"},{"location":"domain-analysis/domain-models/e-scooter/scooter-data.html#weight","text":"Constraints : \\(kilograms > 0\\)","title":"Weight"},{"location":"domain-analysis/domain-models/e-scooter/scooter-data.html#name","text":"Constraints : value must not be empty","title":"Name"},{"location":"domain-analysis/domain-models/e-scooter/scooter-data.html#serialnumber","text":"Constraints value matches ^[A-Za-z0-9-]+$","title":"SerialNumber"},{"location":"domain-analysis/domain-models/e-scooter/scooter-data.html#domain-events","text":"ScooterCreated : emitted when a new scooter is registered to the system. ScooterDeleted : emitted when a scooter is removed from the system.","title":"Domain events"},{"location":"domain-analysis/domain-models/insight/drop-points-planning.html","text":"Drop Points Planning Domain Class Diagram Details Drop Point A drop point is a GeoPoint representing a suggested spot where to place some scooters.","title":"Drop Points Planning Domain"},{"location":"domain-analysis/domain-models/insight/drop-points-planning.html#drop-points-planning-domain","text":"","title":"Drop Points Planning Domain"},{"location":"domain-analysis/domain-models/insight/drop-points-planning.html#class-diagram","text":"","title":"Class Diagram"},{"location":"domain-analysis/domain-models/insight/drop-points-planning.html#details","text":"","title":"Details"},{"location":"domain-analysis/domain-models/insight/drop-points-planning.html#drop-point","text":"A drop point is a GeoPoint representing a suggested spot where to place some scooters.","title":"Drop Point"},{"location":"domain-analysis/domain-models/rent/rent-payment.html","text":"Rent Payment Domain Model Class Diagram Domain Events RentPaymentAuthorized : when a customer has enough credit to pay the unlocking fee. RentPaymentRejected : when a customer does not have enough credit to pay the unlocking fee. CreditExhaustedForRent : when the credit of a customer is not enough to pay the upkeep cost while riding a scooter for a rent.","title":"Rent Payment Domain Model"},{"location":"domain-analysis/domain-models/rent/rent-payment.html#rent-payment-domain-model","text":"","title":"Rent Payment Domain Model"},{"location":"domain-analysis/domain-models/rent/rent-payment.html#class-diagram","text":"","title":"Class Diagram"},{"location":"domain-analysis/domain-models/rent/rent-payment.html#domain-events","text":"RentPaymentAuthorized : when a customer has enough credit to pay the unlocking fee. RentPaymentRejected : when a customer does not have enough credit to pay the unlocking fee. CreditExhaustedForRent : when the credit of a customer is not enough to pay the upkeep cost while riding a scooter for a rent.","title":"Domain Events"},{"location":"domain-analysis/domain-models/rent/rent.html","text":"Rent Domain Model Class Diagram Rules A scooter has three properties that decide if customers have the ability to rent it. enabled : a scooter disabled by an employee cannot be rented; standby : a scooter in standby mode cannot be rented; outOfService : a scooter outside of its area of service cannot be rented. While this context has the authority over the enabled property, the remaining are owned by different contexts which Rent has to integrate with. The combination of the aforementioned properties defines the rentability of a scooter for what concerns the rent context . In addition, a scooter cannot be rented by any customer if another customer is already riding it. This defines its availability state. In order to succeed, a rent request must be made on a scooter that is both rentable and available at the time of the request. Finally, a constraint exists to prevent customers from renting scooter while another rent is ongoing for them. Rent lifecycle diagram Rent Process Diagram Domain Events Rent aggregate RentRequested : When a customer requests a rent. RentConfirmed : When a rent is confirmed. RentStopped : When a rent is stopped. RentCancelled : When a rent is cancelled. RentEnded : When a rent is ended either by cancellation or by stop. Scooter aggregate ScooterEnabled : When a scooter is enabled. ScooterDisabled : When a scooter is disabled. ScooterBecameRentable : When the combination of enabled/out of service/standby is changed to make the scooter rentable. ScooterBecameNotRentable : When the combination of enabled/out of service/standby is changed to make the scooter not rentable.","title":"Rent Domain Model"},{"location":"domain-analysis/domain-models/rent/rent.html#rent-domain-model","text":"","title":"Rent Domain Model"},{"location":"domain-analysis/domain-models/rent/rent.html#class-diagram","text":"","title":"Class Diagram"},{"location":"domain-analysis/domain-models/rent/rent.html#rules","text":"A scooter has three properties that decide if customers have the ability to rent it. enabled : a scooter disabled by an employee cannot be rented; standby : a scooter in standby mode cannot be rented; outOfService : a scooter outside of its area of service cannot be rented. While this context has the authority over the enabled property, the remaining are owned by different contexts which Rent has to integrate with. The combination of the aforementioned properties defines the rentability of a scooter for what concerns the rent context . In addition, a scooter cannot be rented by any customer if another customer is already riding it. This defines its availability state. In order to succeed, a rent request must be made on a scooter that is both rentable and available at the time of the request. Finally, a constraint exists to prevent customers from renting scooter while another rent is ongoing for them.","title":"Rules"},{"location":"domain-analysis/domain-models/rent/rent.html#rent-lifecycle-diagram","text":"","title":"Rent lifecycle diagram"},{"location":"domain-analysis/domain-models/rent/rent.html#rent-process-diagram","text":"","title":"Rent Process Diagram"},{"location":"domain-analysis/domain-models/rent/rent.html#domain-events","text":"","title":"Domain Events"},{"location":"domain-analysis/domain-models/rent/rent.html#rent-aggregate","text":"RentRequested : When a customer requests a rent. RentConfirmed : When a rent is confirmed. RentStopped : When a rent is stopped. RentCancelled : When a rent is cancelled. RentEnded : When a rent is ended either by cancellation or by stop.","title":"Rent aggregate"},{"location":"domain-analysis/domain-models/rent/rent.html#scooter-aggregate","text":"ScooterEnabled : When a scooter is enabled. ScooterDisabled : When a scooter is disabled. ScooterBecameRentable : When the combination of enabled/out of service/standby is changed to make the scooter rentable. ScooterBecameNotRentable : When the combination of enabled/out of service/standby is changed to make the scooter not rentable.","title":"Scooter aggregate"},{"location":"domain-analysis/domain-models/rent/trip.html","text":"Trip Domain Model Class Diagram Domain Events TripStarted : when a new trip starts. TripEnded : when a trip ends.","title":"Trip Domain Model"},{"location":"domain-analysis/domain-models/rent/trip.html#trip-domain-model","text":"","title":"Trip Domain Model"},{"location":"domain-analysis/domain-models/rent/trip.html#class-diagram","text":"","title":"Class Diagram"},{"location":"domain-analysis/domain-models/rent/trip.html#domain-events","text":"TripStarted : when a new trip starts. TripEnded : when a trip ends.","title":"Domain Events"},{"location":"domain-exploration/SUMMARY.html","text":"Business Problem Analysis Ubiquitous Language","title":"SUMMARY"},{"location":"domain-exploration/business-problem-analysis.html","text":"Business Problem Analysis In order to kick-off the knowledge crunching process, the first discussion with the stakeholders is focused on the identification of the business needs. The objective is to derive how it might be possible to create a software system that could maximise the company business gain/value. While doing so the analysts start developing the Ubiquitous Language in parallel, to write down the definition of the domain terminology given that they have a clear understanding of the vocabulary in the domain space. Stakeholders Interview What is the problem that you're trying to solve by adopting a new software solution? We would like to increase the average number of E-scooter rents in a day. What are the possible factors that influence that? Electric scooters have batteries that run out during the day, we often are not able to recharge them until night so we progressively lose available scooters as the day goes on. Do you think there is a way to save some battery during the day to make the scooter last longer? Speed is the main factor that drain the scooter battery. If you want to go fast the motor consumes more energy, maybe speed control might be a thing to look into. Also it's very important that scooters with a low level of battery don't turn off because we can lose the tracking. About that, should the users be prevented from picking up very low battery scooters? Yes we would like that so we don't encounter problems. Also we would like to be very upfront with our customers about the information about the scooter when they need to choose one: if you need to do a long trip the worst thing that can happen is to have your scooter stop at some point and need to find another one. Why is it hard to recover and recharge a scooter? We scatter scooters around the city and then let people wander and drop them off wherever they like, sometimes they can be pretty far away from each other and make the recovering process tedious and costly to do during the day. If it was easier do you think you would be able to recharge some drained scooter and put them back as available? Yes it should be doable, the scooters take about 3 hours to recharge and then they are ready to go again. What else do you think can improve the number of rents? We noticed that not all scooters are used in the same way. In some areas they are quickly depleted whilst in some others they stay basically fully charged and sometime we recover them in the same spot where we dropped them. Also the same scooter can travel a long distance either by a lot of short trips or very long ones depending on the area but we have little data on that. How do you choose where to place your scooters? Right now we're going by trial and error basically, and then we try to note down which places are the best. If one day we see that all the scooters in a spot have been used we try to put some more in the next one. Our objective is that if you need a scooter you should never have to walk too much to find one. Impact Mapping The result of the interview is summed up into an impact map, identifying the root problem and different possible features of interest that raised from the discussion. Theese can be later further developed through the analysis of the usecases and evolve in the system requirements.","title":"Business Problem Analysis"},{"location":"domain-exploration/business-problem-analysis.html#business-problem-analysis","text":"In order to kick-off the knowledge crunching process, the first discussion with the stakeholders is focused on the identification of the business needs. The objective is to derive how it might be possible to create a software system that could maximise the company business gain/value. While doing so the analysts start developing the Ubiquitous Language in parallel, to write down the definition of the domain terminology given that they have a clear understanding of the vocabulary in the domain space.","title":"Business Problem Analysis"},{"location":"domain-exploration/business-problem-analysis.html#stakeholders-interview","text":"What is the problem that you're trying to solve by adopting a new software solution? We would like to increase the average number of E-scooter rents in a day. What are the possible factors that influence that? Electric scooters have batteries that run out during the day, we often are not able to recharge them until night so we progressively lose available scooters as the day goes on. Do you think there is a way to save some battery during the day to make the scooter last longer? Speed is the main factor that drain the scooter battery. If you want to go fast the motor consumes more energy, maybe speed control might be a thing to look into. Also it's very important that scooters with a low level of battery don't turn off because we can lose the tracking. About that, should the users be prevented from picking up very low battery scooters? Yes we would like that so we don't encounter problems. Also we would like to be very upfront with our customers about the information about the scooter when they need to choose one: if you need to do a long trip the worst thing that can happen is to have your scooter stop at some point and need to find another one. Why is it hard to recover and recharge a scooter? We scatter scooters around the city and then let people wander and drop them off wherever they like, sometimes they can be pretty far away from each other and make the recovering process tedious and costly to do during the day. If it was easier do you think you would be able to recharge some drained scooter and put them back as available? Yes it should be doable, the scooters take about 3 hours to recharge and then they are ready to go again. What else do you think can improve the number of rents? We noticed that not all scooters are used in the same way. In some areas they are quickly depleted whilst in some others they stay basically fully charged and sometime we recover them in the same spot where we dropped them. Also the same scooter can travel a long distance either by a lot of short trips or very long ones depending on the area but we have little data on that. How do you choose where to place your scooters? Right now we're going by trial and error basically, and then we try to note down which places are the best. If one day we see that all the scooters in a spot have been used we try to put some more in the next one. Our objective is that if you need a scooter you should never have to walk too much to find one.","title":"Stakeholders Interview"},{"location":"domain-exploration/business-problem-analysis.html#impact-mapping","text":"The result of the interview is summed up into an impact map, identifying the root problem and different possible features of interest that raised from the discussion. Theese can be later further developed through the analysis of the usecases and evolve in the system requirements.","title":"Impact Mapping"},{"location":"domain-exploration/ubiquitous-language.html","text":"Ubiquitous Language E-Scooter service A service that allows customers to rent electric scooters placed in public areas for a trip within the boundaries of an area of service . Electric Scooter Aliases: e-scooter, scooter Motorized vehicle with two wheels, usable by a person standing on it. It's equipped with some sensors and other devices. E-Scooter equipment Electric engine Uses power from the battery to power the front wheel spin. Wheels and tires The scooter runs on two wheels with air-inflated tires; the front wheel containes a rotating electric engine . Battery Scooter power supply; rechargeable; electric; has finite capacity, power... GPS sensor Global Positioning System; estimates a position on Earth by negotiating it with satellites; based on a free service; works better in open places Speedometer Measures speed using wheel rotations. Accelerometer Measures acceleration forces along the three axis Electronic wheel block Aliases: electric break, electric block If turned on, the wheel becomes very hard to rotate Headlight Light source embedded in the front to enable night usage Manual Breaks Aliases: Breaks, default breaks, disk breaks, rear break Friction based stopping system; Placed on the back wheel; Controlled by a hand lever. Accelerator Handle that controls the speed; If the handle isn't turned the electric break is activated. Speaker A device that can play sounds and can be remotely activated. Mode Aliases: State One of the possible states in which the scooter can be. In each mode, the scooter has a different behavior. Active mode A mode in which the scooter has no electric limit on power. Power Saving mode A mode in which the scooter uses a lower maximum speed to limit power consuption. This happens after the battery gets below a threshold Power Saving threshold The battery level below which the scooter enters Power Saving mode. Standby mode A mode in which the scooter must be disabled due to extremely low battery. Standby threshold The battery level below which the scooter enters Standby mode. Operations Unlock To turn off the electric block Lock To turn on the electric block . Ride Use the scooter to move. Disable To deny the possibility that a customer rents a scooter. Enable To allow the possibility that a customer rents a scooter if the business policies allow it. Maintain Repair any damage and/or recharge the battery. Rent As a customer , paying or exploiting a subscription for unlocking an e-scooter . This action lasts until the scooter is locked again (in normal conditions). Assign to area An e-scooter can be assigned to an area if, from that moment, that e-scooter mutually exclusively belongs to that area . Recover See recovery . Ring Make the speaker play a ringtone, useful to find it. Relationships Belong to area The e-scooter can be only rented and ridden inside that area . Customer Alias: user. A customer for the e-scooter service . Anagraphic information Collection of data about the customer, including first name, date of birth, and all the other possible information useful for the e-scooter service . Subscription A customer has it if they are able to rent e-scooters without paying upfront. Admin Works for the E-Scooter Service . Monitors and manages scooters from a control dashboard. Recovery The act of picking up an e-scooter , providing maintenance and dropping it somewhere inside the area of service sometime later. The scooter may be unlocked if necessary. Recovery assistant Aliases: assistant Works for the e-scooter service and does recoveries with a recovery van . Recovery van A vehicle that allows assistants to recover e-scooters . Map Bidimensional, polar representation of the Earth surface. Shows, for example, streets, buildings, water courses; what scooters can or cannot cross. Area of service Aliases: Service Area The map portion inside which e-scooters assigned to it can be rented. Drop Point A place of interest, inside an area of service, where electric scooter are usually dropped after recovery . Trip Information about a rent period, during and after its lasting. Properties Rider The rider is the customer that rents the e-scooter during the trip. Vehicle The scooter used for transportation. Distance The distance, in meters, traveled during the trip. Start position Aliases: start A point inside the area of service where the vehicle was unlocked . End position Aliases: end A point inside the map where the vehicle was locked because the rent ended. Rent process See scooter operation rent . Authorizing Rent A rent is authorized when the customer has enough virtual currency to pay the unlocking fee . Rejecting Rent A rent is rejected when the customer has not enough virtual currency to pay the unlocking fee . Confirming Rent A rent is confirmed when it's authorized. This marks the starting time of the rent for time-based charging . Payment A payment can be either: - a real-world payment - an in-app payment Payment legacy system The preexisting service that manages customer data and payments for the e-scooter service . Virtual Currency The amount of imaginary money for every customer. Used to pay scooter rents . It can be obtained through real-world purchases . Unlocking fee The price to unlock a scooter before initiating a rent. Charged only once per rent. Time based charging The process of charging an amount of virtual currency depending on how much time a rent is taking. In-App Payment Aliases: in-app purchase It's a virtual currency transaction inside the system. Real-world payment Aliases: real-world purchase It's a money transaction from the customer to the business bank account.","title":"Ubiquitous Language"},{"location":"domain-exploration/ubiquitous-language.html#ubiquitous-language","text":"","title":"Ubiquitous Language"},{"location":"domain-exploration/ubiquitous-language.html#e-scooter-service","text":"A service that allows customers to rent electric scooters placed in public areas for a trip within the boundaries of an area of service .","title":"E-Scooter service"},{"location":"domain-exploration/ubiquitous-language.html#electric-scooter","text":"Aliases: e-scooter, scooter Motorized vehicle with two wheels, usable by a person standing on it. It's equipped with some sensors and other devices.","title":"Electric Scooter"},{"location":"domain-exploration/ubiquitous-language.html#e-scooter-equipment","text":"","title":"E-Scooter equipment"},{"location":"domain-exploration/ubiquitous-language.html#electric-engine","text":"Uses power from the battery to power the front wheel spin.","title":"Electric engine"},{"location":"domain-exploration/ubiquitous-language.html#wheels-and-tires","text":"The scooter runs on two wheels with air-inflated tires; the front wheel containes a rotating electric engine .","title":"Wheels and tires"},{"location":"domain-exploration/ubiquitous-language.html#battery","text":"Scooter power supply; rechargeable; electric; has finite capacity, power...","title":"Battery"},{"location":"domain-exploration/ubiquitous-language.html#gps-sensor","text":"Global Positioning System; estimates a position on Earth by negotiating it with satellites; based on a free service; works better in open places","title":"GPS sensor"},{"location":"domain-exploration/ubiquitous-language.html#speedometer","text":"Measures speed using wheel rotations.","title":"Speedometer"},{"location":"domain-exploration/ubiquitous-language.html#accelerometer","text":"Measures acceleration forces along the three axis","title":"Accelerometer"},{"location":"domain-exploration/ubiquitous-language.html#electronic-wheel-block","text":"Aliases: electric break, electric block If turned on, the wheel becomes very hard to rotate","title":"Electronic wheel block"},{"location":"domain-exploration/ubiquitous-language.html#headlight","text":"Light source embedded in the front to enable night usage","title":"Headlight"},{"location":"domain-exploration/ubiquitous-language.html#manual-breaks","text":"Aliases: Breaks, default breaks, disk breaks, rear break Friction based stopping system; Placed on the back wheel; Controlled by a hand lever.","title":"Manual Breaks"},{"location":"domain-exploration/ubiquitous-language.html#accelerator","text":"Handle that controls the speed; If the handle isn't turned the electric break is activated.","title":"Accelerator"},{"location":"domain-exploration/ubiquitous-language.html#speaker","text":"A device that can play sounds and can be remotely activated.","title":"Speaker"},{"location":"domain-exploration/ubiquitous-language.html#mode","text":"Aliases: State One of the possible states in which the scooter can be. In each mode, the scooter has a different behavior.","title":"Mode"},{"location":"domain-exploration/ubiquitous-language.html#active-mode","text":"A mode in which the scooter has no electric limit on power.","title":"Active mode"},{"location":"domain-exploration/ubiquitous-language.html#power-saving-mode","text":"A mode in which the scooter uses a lower maximum speed to limit power consuption. This happens after the battery gets below a threshold","title":"Power Saving mode"},{"location":"domain-exploration/ubiquitous-language.html#power-saving-threshold","text":"The battery level below which the scooter enters Power Saving mode.","title":"Power Saving threshold"},{"location":"domain-exploration/ubiquitous-language.html#standby-mode","text":"A mode in which the scooter must be disabled due to extremely low battery.","title":"Standby mode"},{"location":"domain-exploration/ubiquitous-language.html#standby-threshold","text":"The battery level below which the scooter enters Standby mode.","title":"Standby threshold"},{"location":"domain-exploration/ubiquitous-language.html#operations","text":"","title":"Operations"},{"location":"domain-exploration/ubiquitous-language.html#unlock","text":"To turn off the electric block","title":"Unlock"},{"location":"domain-exploration/ubiquitous-language.html#lock","text":"To turn on the electric block .","title":"Lock"},{"location":"domain-exploration/ubiquitous-language.html#ride","text":"Use the scooter to move.","title":"Ride"},{"location":"domain-exploration/ubiquitous-language.html#disable","text":"To deny the possibility that a customer rents a scooter.","title":"Disable"},{"location":"domain-exploration/ubiquitous-language.html#enable","text":"To allow the possibility that a customer rents a scooter if the business policies allow it.","title":"Enable"},{"location":"domain-exploration/ubiquitous-language.html#maintain","text":"Repair any damage and/or recharge the battery.","title":"Maintain"},{"location":"domain-exploration/ubiquitous-language.html#rent","text":"As a customer , paying or exploiting a subscription for unlocking an e-scooter . This action lasts until the scooter is locked again (in normal conditions).","title":"Rent"},{"location":"domain-exploration/ubiquitous-language.html#assign-to-area","text":"An e-scooter can be assigned to an area if, from that moment, that e-scooter mutually exclusively belongs to that area .","title":"Assign to area"},{"location":"domain-exploration/ubiquitous-language.html#recover","text":"See recovery .","title":"Recover"},{"location":"domain-exploration/ubiquitous-language.html#ring","text":"Make the speaker play a ringtone, useful to find it.","title":"Ring"},{"location":"domain-exploration/ubiquitous-language.html#relationships","text":"","title":"Relationships"},{"location":"domain-exploration/ubiquitous-language.html#belong-to-area","text":"The e-scooter can be only rented and ridden inside that area .","title":"Belong to area"},{"location":"domain-exploration/ubiquitous-language.html#customer","text":"Alias: user. A customer for the e-scooter service .","title":"Customer"},{"location":"domain-exploration/ubiquitous-language.html#anagraphic-information","text":"Collection of data about the customer, including first name, date of birth, and all the other possible information useful for the e-scooter service .","title":"Anagraphic information"},{"location":"domain-exploration/ubiquitous-language.html#subscription","text":"A customer has it if they are able to rent e-scooters without paying upfront.","title":"Subscription"},{"location":"domain-exploration/ubiquitous-language.html#admin","text":"Works for the E-Scooter Service . Monitors and manages scooters from a control dashboard.","title":"Admin"},{"location":"domain-exploration/ubiquitous-language.html#recovery","text":"The act of picking up an e-scooter , providing maintenance and dropping it somewhere inside the area of service sometime later. The scooter may be unlocked if necessary.","title":"Recovery"},{"location":"domain-exploration/ubiquitous-language.html#recovery-assistant","text":"Aliases: assistant Works for the e-scooter service and does recoveries with a recovery van .","title":"Recovery assistant"},{"location":"domain-exploration/ubiquitous-language.html#recovery-van","text":"A vehicle that allows assistants to recover e-scooters .","title":"Recovery van"},{"location":"domain-exploration/ubiquitous-language.html#map","text":"Bidimensional, polar representation of the Earth surface. Shows, for example, streets, buildings, water courses; what scooters can or cannot cross.","title":"Map"},{"location":"domain-exploration/ubiquitous-language.html#area-of-service","text":"Aliases: Service Area The map portion inside which e-scooters assigned to it can be rented.","title":"Area of service"},{"location":"domain-exploration/ubiquitous-language.html#drop-point","text":"A place of interest, inside an area of service, where electric scooter are usually dropped after recovery .","title":"Drop Point"},{"location":"domain-exploration/ubiquitous-language.html#trip","text":"Information about a rent period, during and after its lasting.","title":"Trip"},{"location":"domain-exploration/ubiquitous-language.html#properties","text":"","title":"Properties"},{"location":"domain-exploration/ubiquitous-language.html#rider","text":"The rider is the customer that rents the e-scooter during the trip.","title":"Rider"},{"location":"domain-exploration/ubiquitous-language.html#vehicle","text":"The scooter used for transportation.","title":"Vehicle"},{"location":"domain-exploration/ubiquitous-language.html#distance","text":"The distance, in meters, traveled during the trip.","title":"Distance"},{"location":"domain-exploration/ubiquitous-language.html#start-position","text":"Aliases: start A point inside the area of service where the vehicle was unlocked .","title":"Start position"},{"location":"domain-exploration/ubiquitous-language.html#end-position","text":"Aliases: end A point inside the map where the vehicle was locked because the rent ended.","title":"End position"},{"location":"domain-exploration/ubiquitous-language.html#rent-process","text":"See scooter operation rent .","title":"Rent process"},{"location":"domain-exploration/ubiquitous-language.html#authorizing-rent","text":"A rent is authorized when the customer has enough virtual currency to pay the unlocking fee .","title":"Authorizing Rent"},{"location":"domain-exploration/ubiquitous-language.html#rejecting-rent","text":"A rent is rejected when the customer has not enough virtual currency to pay the unlocking fee .","title":"Rejecting Rent"},{"location":"domain-exploration/ubiquitous-language.html#confirming-rent","text":"A rent is confirmed when it's authorized. This marks the starting time of the rent for time-based charging .","title":"Confirming Rent"},{"location":"domain-exploration/ubiquitous-language.html#payment","text":"A payment can be either: - a real-world payment - an in-app payment","title":"Payment"},{"location":"domain-exploration/ubiquitous-language.html#payment-legacy-system","text":"The preexisting service that manages customer data and payments for the e-scooter service .","title":"Payment legacy system"},{"location":"domain-exploration/ubiquitous-language.html#virtual-currency","text":"The amount of imaginary money for every customer. Used to pay scooter rents . It can be obtained through real-world purchases .","title":"Virtual Currency"},{"location":"domain-exploration/ubiquitous-language.html#unlocking-fee","text":"The price to unlock a scooter before initiating a rent. Charged only once per rent.","title":"Unlocking fee"},{"location":"domain-exploration/ubiquitous-language.html#time-based-charging","text":"The process of charging an amount of virtual currency depending on how much time a rent is taking.","title":"Time based charging"},{"location":"domain-exploration/ubiquitous-language.html#in-app-payment","text":"Aliases: in-app purchase It's a virtual currency transaction inside the system.","title":"In-App Payment"},{"location":"domain-exploration/ubiquitous-language.html#real-world-payment","text":"Aliases: real-world purchase It's a money transaction from the customer to the business bank account.","title":"Real-world payment"},{"location":"implementation/index.html","text":"Implementation This section explains how the different parts of the system are organized and implemented. The choice was to carry out the full analysis of a complex domain to be able to approach a \"real-world\" problem in its entirety and use the Domain Driven Design techniques to study it, but as far as the implementation goes, we always knew that it was not needed to implement the whole system, so we decided to focus on the core and interesting aspects, mock the supporting services and completly ignore some of the features that were outside of this core prototype boundary scope. In the end, the most interesting part for us was the implementation of the Scooter Monitor & Control context in order to realize the Digital Twin layer that was at the core of the Pervasive Computer course for which we plan to submit this project too. We then decided to mock the Scooter Data context since it was just a collection of data relevant for the domain but not too much for the functionalities of the system. Since we chose to implement the renting operations in the Rent Context to have at least one \"classic\" microservice in place, we decided to put aside the implementation of the Area of Service context in order to focus on the most relevant use-case of the system itself. In an iterative development process of the real system we imagined that this would have probably been the smartest choice to, at least, guarantee the basic functionalities immediatly and later add the other planned features. With the same reasoning we chose to skip the implementation of the Insights subdomain, the connected Trip Context and simply mock the Rent Payment context since we didn't need to manage the virtual currency and the relationship with the Payment subdomain. The User subdomain was plain both from a design and implementative perspective so we didn't focus too much on that. Of course in a real-world scenario authorization and security should have been put in place since the very beginning, but for a proof-of-concept like the one that we developed this was definetly not needed nor particularly interesting. Scooter Service Backend The backend is fully deployed on Microsoft Azure: each resource is under the e-scooter resource group. The next sections describe the different requirements of the system and how they were realized using resources deployed on the Azure Cloud. Control of the Physical devices The connection with the physical devices is managed through an IoT Hub named scooter-iot-hub . Data aggregation The layer that aggregates the data from all the different sections of the system is implemented making use of Azure Digital Twins and is named scooter-digital-twins . This layer stores the latest updated state of the whole system keeping data about customers, scooters and rents in a comprehensive view and can be used as an eventual consistent source to read data instead of interrogating each microservice. The result structure is a Digital Twin Graph as provided by the azure tool that allow to store current state data about the twins and relationships between each other. Here are the models used on the graph for Scooters and Customers twins. Inter-Service communication Communication among services is carried out in an asynchronous fashion using events queues. Events are carried around between services using a Service Bus named scooter-event-bus on the topic production/service-events . Each subscriber to the scooter-event-bus manages its own subscription filtering only the relevat events to receive. Telemetry events from the devices is transmitted through an Event Grid from the IoTHub. Event Handling Azure functions are generally used as event handlers to map the communication from a service to another and especially when dealing with updating the Digital Twin Layer. Here is a list of all the implemented Azure functions: manage devices is a function that manages the creation and destruction of scooters on the IoTHub and on the Digital Twin Layer. manage customer is a function that manages the creation and destruction of the customers' digital twins. manage rents is a function that manages the creation and destruction of renting relationships on the digital twin graph. manage telemetry updates updates the state of each scooter digital twin when new telemetry is received by the IoTHub (e.g. position, speed). manage reported properties updates the state of each scooter digital twin when reported properties are updated on the device (e.g. lock state, standby). manage scooter availability update the state of each scooter digital twin when the availability is changed from an administrator of the system on the rent service. Two functions instead of managing the state of the Digital Twin Graph are extending the functionalities of the IoTHub to create the equivalent of the Scooter Control & Monitor Context: scooter control is a function that exposes the default applicable actions on the devices: in particular, it manages the lock/unlock command and listens to the telemetries from the IoTHub to apply domain policies (e.g. modifying max speed according to battery level). scooter monitor is a function that exposes the events concerning changes of the device state (e.g. lock, standby) Functions were also used to implement mocked parts of the system when needed. For example the rent payment which is a mock implementation of the Rent Payment context that always confirm the rents. Microservices Microservices are implemented with an App Service . We fully developed as a standalone microservice only the Rent service that maps the Rent Context. Frontend Admin frontend The Admin frontend is implemented using Angular: polling the Digital Twin Layer, it shows the scooters in a 2D map with an icon colored depending on the state of each scooter: Green when it's free; Red when it's currently rented; Yellow when it is in standby; Grey when it is disabled. Clicking on a scooter it is possible to check the value of its properties and enable or disable it to allow or prevent renting. This features are implemented using Angular services. Customer frontend The Customer frontend is implemented in C# using WPF: it is a very simple mock of the mobile app that users could use to rent an available scooter. Scooter Data mock The Scooter Data Mock is a mock implementation with WPF of the Scooter Data context. It allows to create a new scooter identity or to remove an existing one by generating the corresponding events which are then handled by the rest of the system accordingly. It does not store any data about the scooter since this was not relevant for the other core services. Customer mock The Customer Mock is a mock implementation with WPF of the Customer context. It allows to create a new customer identity or to remove an existing one by generating the corresponding events which are then handled by the rest of the system accordingly. It does not store any data about the customer since this was not relevant for the other core services. Device emulator The Device emulator simulates the typical behavior of e-scooters in the real world, allowing us to live-test the entire system. Implemented as HostedService with C# .NET, the emulator executes a loop in which queries for new or updated scooters and simulates a random realistic usage to update them: it moves the scooters, uses the battery and sets standby mode eventually, as if humans were using them to move around Cesena. The requirement analysis of the device emulator can be found here .","title":"Implementation"},{"location":"implementation/index.html#implementation","text":"This section explains how the different parts of the system are organized and implemented. The choice was to carry out the full analysis of a complex domain to be able to approach a \"real-world\" problem in its entirety and use the Domain Driven Design techniques to study it, but as far as the implementation goes, we always knew that it was not needed to implement the whole system, so we decided to focus on the core and interesting aspects, mock the supporting services and completly ignore some of the features that were outside of this core prototype boundary scope. In the end, the most interesting part for us was the implementation of the Scooter Monitor & Control context in order to realize the Digital Twin layer that was at the core of the Pervasive Computer course for which we plan to submit this project too. We then decided to mock the Scooter Data context since it was just a collection of data relevant for the domain but not too much for the functionalities of the system. Since we chose to implement the renting operations in the Rent Context to have at least one \"classic\" microservice in place, we decided to put aside the implementation of the Area of Service context in order to focus on the most relevant use-case of the system itself. In an iterative development process of the real system we imagined that this would have probably been the smartest choice to, at least, guarantee the basic functionalities immediatly and later add the other planned features. With the same reasoning we chose to skip the implementation of the Insights subdomain, the connected Trip Context and simply mock the Rent Payment context since we didn't need to manage the virtual currency and the relationship with the Payment subdomain. The User subdomain was plain both from a design and implementative perspective so we didn't focus too much on that. Of course in a real-world scenario authorization and security should have been put in place since the very beginning, but for a proof-of-concept like the one that we developed this was definetly not needed nor particularly interesting.","title":"Implementation"},{"location":"implementation/index.html#scooter-service-backend","text":"The backend is fully deployed on Microsoft Azure: each resource is under the e-scooter resource group. The next sections describe the different requirements of the system and how they were realized using resources deployed on the Azure Cloud.","title":"Scooter Service Backend"},{"location":"implementation/index.html#control-of-the-physical-devices","text":"The connection with the physical devices is managed through an IoT Hub named scooter-iot-hub .","title":"Control of the Physical devices"},{"location":"implementation/index.html#data-aggregation","text":"The layer that aggregates the data from all the different sections of the system is implemented making use of Azure Digital Twins and is named scooter-digital-twins . This layer stores the latest updated state of the whole system keeping data about customers, scooters and rents in a comprehensive view and can be used as an eventual consistent source to read data instead of interrogating each microservice. The result structure is a Digital Twin Graph as provided by the azure tool that allow to store current state data about the twins and relationships between each other. Here are the models used on the graph for Scooters and Customers twins.","title":"Data aggregation"},{"location":"implementation/index.html#inter-service-communication","text":"Communication among services is carried out in an asynchronous fashion using events queues. Events are carried around between services using a Service Bus named scooter-event-bus on the topic production/service-events . Each subscriber to the scooter-event-bus manages its own subscription filtering only the relevat events to receive. Telemetry events from the devices is transmitted through an Event Grid from the IoTHub.","title":"Inter-Service communication"},{"location":"implementation/index.html#event-handling","text":"Azure functions are generally used as event handlers to map the communication from a service to another and especially when dealing with updating the Digital Twin Layer. Here is a list of all the implemented Azure functions: manage devices is a function that manages the creation and destruction of scooters on the IoTHub and on the Digital Twin Layer. manage customer is a function that manages the creation and destruction of the customers' digital twins. manage rents is a function that manages the creation and destruction of renting relationships on the digital twin graph. manage telemetry updates updates the state of each scooter digital twin when new telemetry is received by the IoTHub (e.g. position, speed). manage reported properties updates the state of each scooter digital twin when reported properties are updated on the device (e.g. lock state, standby). manage scooter availability update the state of each scooter digital twin when the availability is changed from an administrator of the system on the rent service. Two functions instead of managing the state of the Digital Twin Graph are extending the functionalities of the IoTHub to create the equivalent of the Scooter Control & Monitor Context: scooter control is a function that exposes the default applicable actions on the devices: in particular, it manages the lock/unlock command and listens to the telemetries from the IoTHub to apply domain policies (e.g. modifying max speed according to battery level). scooter monitor is a function that exposes the events concerning changes of the device state (e.g. lock, standby) Functions were also used to implement mocked parts of the system when needed. For example the rent payment which is a mock implementation of the Rent Payment context that always confirm the rents.","title":"Event Handling"},{"location":"implementation/index.html#microservices","text":"Microservices are implemented with an App Service . We fully developed as a standalone microservice only the Rent service that maps the Rent Context.","title":"Microservices"},{"location":"implementation/index.html#frontend","text":"","title":"Frontend"},{"location":"implementation/index.html#admin-frontend","text":"The Admin frontend is implemented using Angular: polling the Digital Twin Layer, it shows the scooters in a 2D map with an icon colored depending on the state of each scooter: Green when it's free; Red when it's currently rented; Yellow when it is in standby; Grey when it is disabled. Clicking on a scooter it is possible to check the value of its properties and enable or disable it to allow or prevent renting. This features are implemented using Angular services.","title":"Admin frontend"},{"location":"implementation/index.html#customer-frontend","text":"The Customer frontend is implemented in C# using WPF: it is a very simple mock of the mobile app that users could use to rent an available scooter.","title":"Customer frontend"},{"location":"implementation/index.html#scooter-data-mock","text":"The Scooter Data Mock is a mock implementation with WPF of the Scooter Data context. It allows to create a new scooter identity or to remove an existing one by generating the corresponding events which are then handled by the rest of the system accordingly. It does not store any data about the scooter since this was not relevant for the other core services.","title":"Scooter Data mock"},{"location":"implementation/index.html#customer-mock","text":"The Customer Mock is a mock implementation with WPF of the Customer context. It allows to create a new customer identity or to remove an existing one by generating the corresponding events which are then handled by the rest of the system accordingly. It does not store any data about the customer since this was not relevant for the other core services.","title":"Customer mock"},{"location":"implementation/index.html#device-emulator","text":"The Device emulator simulates the typical behavior of e-scooters in the real world, allowing us to live-test the entire system. Implemented as HostedService with C# .NET, the emulator executes a loop in which queries for new or updated scooters and simulates a random realistic usage to update them: it moves the scooters, uses the battery and sets standby mode eventually, as if humans were using them to move around Cesena. The requirement analysis of the device emulator can be found here .","title":"Device emulator"},{"location":"implementation/SUMMARY.html","text":"Implementation Device Emulator Digital Twins Models","title":"SUMMARY"},{"location":"implementation/digital-twins-models.html","text":"Digital Twins Scooter DT Model { \"@context\" : \"dtmi:dtdl:context;2\" , \"@id\" : \"dtmi:com:escooter:EScooter;1\" , \"@type\" : \"Interface\" , \"displayName\" : \"E-Scooter\" , \"contents\" : [ { \"@type\" : [ \"Property\" , \"TimeSpan\" ], \"name\" : \"UpdateFrequency\" , \"schema\" : \"integer\" , \"unit\" : \"second\" , \"writable\" : true }, { \"@type\" : \"Property\" , \"name\" : \"Locked\" , \"schema\" : \"boolean\" , \"writable\" : true }, { \"@type\" : \"Property\" , \"name\" : \"Enabled\" , \"schema\" : \"boolean\" , \"writable\" : true }, { \"@type\" : [ \"Property\" , \"Velocity\" ], \"name\" : \"MaxSpeed\" , \"schema\" : \"double\" , \"unit\" : \"kilometrePerHour\" , \"writable\" : true }, { \"@type\" : \"Property\" , \"name\" : \"Connected\" , \"schema\" : \"boolean\" }, { \"@type\" : \"Property\" , \"name\" : \"Standby\" , \"schema\" : \"boolean\" }, { \"@type\" : \"Property\" , \"name\" : \"BatteryLevel\" , \"schema\" : \"double\" , \"comment\" : \"percentage semantic type is missing\" }, { \"@type\" : [ \"Property\" , \"Latitude\" ], \"name\" : \"Latitude\" , \"schema\" : \"double\" , \"unit\" : \"degreeOfArc\" }, { \"@type\" : [ \"Property\" , \"Longitude\" ], \"name\" : \"Longitude\" , \"schema\" : \"double\" , \"unit\" : \"degreeOfArc\" }, { \"@type\" : [ \"Property\" , \"Velocity\" ], \"name\" : \"Speed\" , \"schema\" : \"double\" , \"unit\" : \"kilometrePerHour\" } ] } Customer DT Model { \"@context\" : \"dtmi:dtdl:context;2\" , \"@id\" : \"dtmi:com:escooter:Customer;1\" , \"@type\" : \"Interface\" , \"displayName\" : \"Customer\" , \"contents\" : [ { \"@type\" : \"Relationship\" , \"name\" : \"is_riding\" , \"displayName\" : \"is riding\" , \"target\" : \"dtmi:com:escooter:EScooter;1\" , \"properties\" : [ { \"@type\" : \"Property\" , \"name\" : \"start\" , \"schema\" : \"dateTime\" } ] } ] }","title":"Digital Twins Models"},{"location":"implementation/digital-twins-models.html#digital-twins","text":"","title":"Digital Twins"},{"location":"implementation/digital-twins-models.html#scooter-dt","text":"","title":"Scooter DT"},{"location":"implementation/digital-twins-models.html#model","text":"{ \"@context\" : \"dtmi:dtdl:context;2\" , \"@id\" : \"dtmi:com:escooter:EScooter;1\" , \"@type\" : \"Interface\" , \"displayName\" : \"E-Scooter\" , \"contents\" : [ { \"@type\" : [ \"Property\" , \"TimeSpan\" ], \"name\" : \"UpdateFrequency\" , \"schema\" : \"integer\" , \"unit\" : \"second\" , \"writable\" : true }, { \"@type\" : \"Property\" , \"name\" : \"Locked\" , \"schema\" : \"boolean\" , \"writable\" : true }, { \"@type\" : \"Property\" , \"name\" : \"Enabled\" , \"schema\" : \"boolean\" , \"writable\" : true }, { \"@type\" : [ \"Property\" , \"Velocity\" ], \"name\" : \"MaxSpeed\" , \"schema\" : \"double\" , \"unit\" : \"kilometrePerHour\" , \"writable\" : true }, { \"@type\" : \"Property\" , \"name\" : \"Connected\" , \"schema\" : \"boolean\" }, { \"@type\" : \"Property\" , \"name\" : \"Standby\" , \"schema\" : \"boolean\" }, { \"@type\" : \"Property\" , \"name\" : \"BatteryLevel\" , \"schema\" : \"double\" , \"comment\" : \"percentage semantic type is missing\" }, { \"@type\" : [ \"Property\" , \"Latitude\" ], \"name\" : \"Latitude\" , \"schema\" : \"double\" , \"unit\" : \"degreeOfArc\" }, { \"@type\" : [ \"Property\" , \"Longitude\" ], \"name\" : \"Longitude\" , \"schema\" : \"double\" , \"unit\" : \"degreeOfArc\" }, { \"@type\" : [ \"Property\" , \"Velocity\" ], \"name\" : \"Speed\" , \"schema\" : \"double\" , \"unit\" : \"kilometrePerHour\" } ] }","title":"Model"},{"location":"implementation/digital-twins-models.html#customer-dt","text":"","title":"Customer DT"},{"location":"implementation/digital-twins-models.html#model_1","text":"{ \"@context\" : \"dtmi:dtdl:context;2\" , \"@id\" : \"dtmi:com:escooter:Customer;1\" , \"@type\" : \"Interface\" , \"displayName\" : \"Customer\" , \"contents\" : [ { \"@type\" : \"Relationship\" , \"name\" : \"is_riding\" , \"displayName\" : \"is riding\" , \"target\" : \"dtmi:com:escooter:EScooter;1\" , \"properties\" : [ { \"@type\" : \"Property\" , \"name\" : \"start\" , \"schema\" : \"dateTime\" } ] } ] }","title":"Model"},{"location":"implementation/device-emulator/requirements.html","text":"Device Emulator Requirements Emulate all the devices on a Iot Hub instance Fetch the list of all devices, periodically For each device, start an infinite emulation that lasts until a \"stop event\" is fired A stop event can be a keyboard interrupt or a C# method call The emulation consists of: Load device data Decide which property should be changed, why and how If the device is locked, do nothing If it's unlocked, randomly select an action: Do nothing Change position based on velocity (only if velocity is not 0) Change position and change velocity If it's moving, consume some battery If the battery is below the standby threshold go in standby mode Change the property values Submit the update to IoT Hub Note Emulating a device means firing a sequence of realistic updates on its reported properties on IoT Hub. We consider every device to be an E-Scooter . Can be executed both as script and as a library","title":"Device Emulator Requirements"},{"location":"implementation/device-emulator/requirements.html#device-emulator-requirements","text":"Emulate all the devices on a Iot Hub instance Fetch the list of all devices, periodically For each device, start an infinite emulation that lasts until a \"stop event\" is fired A stop event can be a keyboard interrupt or a C# method call The emulation consists of: Load device data Decide which property should be changed, why and how If the device is locked, do nothing If it's unlocked, randomly select an action: Do nothing Change position based on velocity (only if velocity is not 0) Change position and change velocity If it's moving, consume some battery If the battery is below the standby threshold go in standby mode Change the property values Submit the update to IoT Hub Note Emulating a device means firing a sequence of realistic updates on its reported properties on IoT Hub. We consider every device to be an E-Scooter . Can be executed both as script and as a library","title":"Device Emulator Requirements"},{"location":"requirement-analysis/index.html","text":"Analysis Process After analyzing the domain, the second meeting with the experts focused on the expected requirements of the whole system. This interview was conducted following the process of defining user-stories from different perspectives in order to deduce the overall behaviour of the system from the expectations that the customer/experts had about the required functionalities. A Use Case UML diagram was produced from those stories, detailing how the different use cases were related to each other and to the actors of the system. In the end, three main actors of the system were identified: Customers are the people that rent scooters through the service Managers monitor the scooters on a remote dashboard and can inspect the insights to see the suggested drop points Assistants are on the field and recover scooters that need to be recharged and drop charged scooters in the suggested drop points Most of the use cases relate to the Customers and to the processes that need to happen before and while a customer rents a scooter. This is because the expected behavior from the customers point of view is the focus for the business success. Result","title":"Analysis Process"},{"location":"requirement-analysis/index.html#analysis-process","text":"After analyzing the domain, the second meeting with the experts focused on the expected requirements of the whole system. This interview was conducted following the process of defining user-stories from different perspectives in order to deduce the overall behaviour of the system from the expectations that the customer/experts had about the required functionalities. A Use Case UML diagram was produced from those stories, detailing how the different use cases were related to each other and to the actors of the system. In the end, three main actors of the system were identified: Customers are the people that rent scooters through the service Managers monitor the scooters on a remote dashboard and can inspect the insights to see the suggested drop points Assistants are on the field and recover scooters that need to be recharged and drop charged scooters in the suggested drop points Most of the use cases relate to the Customers and to the processes that need to happen before and while a customer rents a scooter. This is because the expected behavior from the customers point of view is the focus for the business success.","title":"Analysis Process"},{"location":"requirement-analysis/index.html#result","text":"","title":"Result"},{"location":"requirement-analysis/SUMMARY.html","text":"User stories","title":"SUMMARY"},{"location":"requirement-analysis/user-stories.html","text":"User stories Some user stories are taken from end users and some other are taken from the business representative, business employees. 1a - Search of a scooter As a customer, I want to open the mobile application and search for free scooters in my area. 1b - Choose and find a scooter As a customer, I want to be able to select a scooter near myself and make it ring in order to find it if it's hidden. 1c - Rent a scooter As a customer, I want to confirm on my phone and start riding. When I'm done, I want to leave the scooter where I can and confirm the end of the trip on the app. 2 - Battery level As a customer, when I'm searching a scooter, I want to know its battery level in advance. 3a - Area of service policy When a scooter is taken out of the area of service borders, it locks. 3b - Customer notification of the area border As a customer, when I'm approaching the area of service border, I want to be warned about the possibility that my scooter gets locked. How do you want to get warned? I'd like the scooter to play a specific sound, while I get a notification on my phone. 4 - Power save policy When the battery goes below a threshold, the scooter enters a power save mode, during which it runs slower than normal. 5 - Customer notification of battery usage As a customer, I want to be warned when the battery is running low. I want to be warned with a ringtone. 6 - Battery exhausted policy When the battery is running low, the scooter warns the customer, if present, that the run must end and enters a standby mode during which it's disabled. 7 - Monitoring of scooters As the business manager, I want to be able to see the position and the battery level of every scooter in a map. 8 - Insights from the system As the business manager, I want to get suggestions about strategic places for the drop points of the next day. 9 - Unlock policy for employees. As a business employee I want to be able to unlock freely the scooters in order to move them. 10 - Vandalism prevention The scooter should discourage theft and vandalism by playing a message when moved while locked or disabled. 11 - Integration with legacy payment system As the business manager, I want the customers to pay for rides through the existing system. Does the legacy system keep track of all customers data? If I remember correctly, yes. From the legacy system documentation: The legacy payment system needs access to trip data and to customers rent/unlock requests. Stories diagrams Renting process diagram","title":"User stories"},{"location":"requirement-analysis/user-stories.html#user-stories","text":"Some user stories are taken from end users and some other are taken from the business representative, business employees.","title":"User stories"},{"location":"requirement-analysis/user-stories.html#1a-search-of-a-scooter","text":"As a customer, I want to open the mobile application and search for free scooters in my area.","title":"1a - Search of a scooter"},{"location":"requirement-analysis/user-stories.html#1b-choose-and-find-a-scooter","text":"As a customer, I want to be able to select a scooter near myself and make it ring in order to find it if it's hidden.","title":"1b - Choose and find a scooter"},{"location":"requirement-analysis/user-stories.html#1c-rent-a-scooter","text":"As a customer, I want to confirm on my phone and start riding. When I'm done, I want to leave the scooter where I can and confirm the end of the trip on the app.","title":"1c - Rent a scooter"},{"location":"requirement-analysis/user-stories.html#2-battery-level","text":"As a customer, when I'm searching a scooter, I want to know its battery level in advance.","title":"2 - Battery level"},{"location":"requirement-analysis/user-stories.html#3a-area-of-service-policy","text":"When a scooter is taken out of the area of service borders, it locks.","title":"3a - Area of service policy"},{"location":"requirement-analysis/user-stories.html#3b-customer-notification-of-the-area-border","text":"As a customer, when I'm approaching the area of service border, I want to be warned about the possibility that my scooter gets locked. How do you want to get warned? I'd like the scooter to play a specific sound, while I get a notification on my phone.","title":"3b - Customer notification of the area border"},{"location":"requirement-analysis/user-stories.html#4-power-save-policy","text":"When the battery goes below a threshold, the scooter enters a power save mode, during which it runs slower than normal.","title":"4 - Power save policy"},{"location":"requirement-analysis/user-stories.html#5-customer-notification-of-battery-usage","text":"As a customer, I want to be warned when the battery is running low. I want to be warned with a ringtone.","title":"5 - Customer notification of battery usage"},{"location":"requirement-analysis/user-stories.html#6-battery-exhausted-policy","text":"When the battery is running low, the scooter warns the customer, if present, that the run must end and enters a standby mode during which it's disabled.","title":"6 - Battery exhausted policy"},{"location":"requirement-analysis/user-stories.html#7-monitoring-of-scooters","text":"As the business manager, I want to be able to see the position and the battery level of every scooter in a map.","title":"7 - Monitoring of scooters"},{"location":"requirement-analysis/user-stories.html#8-insights-from-the-system","text":"As the business manager, I want to get suggestions about strategic places for the drop points of the next day.","title":"8 - Insights from the system"},{"location":"requirement-analysis/user-stories.html#9-unlock-policy-for-employees","text":"As a business employee I want to be able to unlock freely the scooters in order to move them.","title":"9 - Unlock policy for employees."},{"location":"requirement-analysis/user-stories.html#10-vandalism-prevention","text":"The scooter should discourage theft and vandalism by playing a message when moved while locked or disabled.","title":"10 - Vandalism prevention"},{"location":"requirement-analysis/user-stories.html#11-integration-with-legacy-payment-system","text":"As the business manager, I want the customers to pay for rides through the existing system. Does the legacy system keep track of all customers data? If I remember correctly, yes. From the legacy system documentation: The legacy payment system needs access to trip data and to customers rent/unlock requests.","title":"11 - Integration with legacy payment system"},{"location":"requirement-analysis/user-stories.html#stories-diagrams","text":"","title":"Stories diagrams"},{"location":"requirement-analysis/user-stories.html#renting-process-diagram","text":"","title":"Renting process diagram"}]}; var __search = { index: Promise.resolve(local_index) }